<div 
  ref:root 
  class="d3zoom" 
  bind:clientWidth
  bind:clientHeight
  on:mousemove="mouseMove(event)"
  on:mousedown="set({msx: null, msy: null})"
  on:mouseout="set({msx: null, msy: null})"
>
  <slot />
</div>

<script>
import {zoomIdentity as d3ZoomIdentity, zoom as d3Zoom, zoomTransform as d3ZoomTransform} from "d3-zoom";
import {event as d3Event, select as d3Select} from "d3-selection";
import { tween } from 'svelte-extras';
import * as eases from 'eases-jsnext';

export default {
  data() {
    return {
      z: d3Zoom(), //d3 zoom object
      el: null,
      selection: null, //the d3 selection of the root
      transform: null, // the d3 transform
      scaleExtent: [1, 32], //
      scrollWheel: false,
      scale: 1,
      translateX: 0,
      translateY: 0,
      msx: null,
      msy: null,
      k: 1,
      x: 0,
      y: 0
    };
  },
  computed: {
    minSize: ({clientWidth, clientHeight}) => Math.min(clientWidth, clientHeight),
    mouseOver: ({msx, msy}) => msx != undefined && msy != undefined,
    mouseGlobalPosition: ({transform, msx, msy, clientHeight, clientWidth, minSize}) => {
      if (transform && msx != undefined && msy != undefined) {
        return [
          transform.invertX(msx) - (clientWidth - minSize) / 2,
          transform.invertY(msy) - (clientHeight - minSize) / 2,
        ];
      } else {
        return null;
      }
    },
    extent: ({scale, translateX, translateY, minSize, clientWidth, clientHeight}) => {
      const x0 = - translateX / scale;
      const y0 = - translateY / scale;
      const x1 = x0 + clientWidth / scale;
      const y1 = y0 + clientHeight / scale;
      return [
        [x0 / minSize, x1 / minSize],
        [y0 / minSize, y1 / minSize],
      ]
    },
  },
  
  oncreate() {
    const {z, scaleExtent, clientWidth, clientHeight} = this.get();
    const that = this; // needed because d3 gives "this" as the node, not component.
    z.scaleExtent(scaleExtent);
    const selection = d3Select(this.refs.root);
    z(selection);
    z.translateTo(selection, Math.min(clientWidth, clientHeight) / 2, Math.min(clientWidth, clientHeight) / 2)
    this.set({
      selection,
      el: this.refs.root,
    });
    z.on("zoom", () => { this.onzoom(that); });
    z.filter(this.zoomEventFilter.bind(this))
    this.update();
  },
  onstate({changed, current, previous}) {
    if (previous != undefined) {
      if ((changed.clientWidth || changed.clientHeight) && current.el) {
        this.update();
      }
    }
    // console.log("update", changed, current.scale)
    const {z, selection, el, x, y} = this.get();
    if (changed.scaleExtent && current.scaleExtent) { z.scaleExtent(current.scaleExtent) } 
    if (selection) {

      if (changed.x || changed.y) {
        z.translateTo(selection, current.x, current.y);
      }

      if (changed.scale) { this.set({k: current.scale}); }
      if (changed.k) { z.scaleTo(selection, current.k); } 

      if (changed.translateX) { this.set({x: current.translateX}); }
      if (changed.translateY) { this.set({x: current.translateY}); }

    }
  },
  methods: {
    tween,
    zoomEventFilter: function() {
      const {scrollWheel} = this.get();
      if (!scrollWheel) {
        return d3Event.type !== "wheel" && !d3Event.button;
      } else {
        return !d3Event.button;
      }
    },
    mouseMove: function(event) {
      const msx = event.offsetX;
      const msy = event.offsetY;
      this.set({
        msx, msy
      });
      const {mouseGlobalPosition} = this.get();
    },
    update: function() {
      const {clientWidth, clientHeight, minSize, el, z} = this.get();
      const transform = d3ZoomTransform(el);
      const scale = transform.k;
      this.set({
        scale,
        transform,
        translateX: transform.x + scale * (clientWidth - minSize) / 2,
        translateY: transform.y + scale * (clientHeight - minSize) / 2,
      });
    },
    onzoom: function(that) {
      that.update();
    },
    transformTo: function(x, y, scale) {

    },
    translateTo: function() {

    },
    home: function() {
      const {selection, z} = this.get();

      selection.transition()
        .duration(1500)
        .call(z.transform, d3ZoomIdentity);
    },
    zoomTo: function(scale, duration) {
      const {scaleExtent} = this.get()
      scale = Math.min(scale, scaleExtent[1]);
      scale = Math.max(scale, scaleExtent[0]);
      if (duration) {
        this.tween('k', scale, {
          duration, easing: eases.cubicInOut
        });
      } else {
        this.set({k: scale});
      }
    }
  }
}
</script>

<style>
ref:root {
  position: relative;
  background: white;
  width: 100%;
  height: 100%;
}
</style>