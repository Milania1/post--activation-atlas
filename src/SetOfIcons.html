<div ref:annotation bind:clientWidth=width bind:clientHeight=height>
  <div style="position: relative;height: 10px;">
    <div style="position: absolute; left: 0px; top: 1px;background-color:{color}; border-radius: 50%; width: 8px; height: 8px;"></div>
    <div style="position: relative; top: 4px; margin: 0 4px; border-top: solid 2px {color}; "></div>
    <svg style="position: absolute; right: -4px; top: 0;" width=10 height=10 viewBox="0 0 10 10">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="{color}" />
    </svg>
  </div>
  <div ref:icons class="icons">
    {#each imgList as icon, i}
      <ClippedIcon
        icon={icon}
        width={100}
        {config}
      />
    {/each}
  </div>
</div>


<script>
export default {
  components: { 
    ClippedIcon: "./ClippedIcon.html",
  },
  data() {
    return {
      container: null,
      arrow: null,
      arrowHeight: 30,
      imgList: [],
      color: '#ff6600',
    }
  },
  computed: {
    // choose the deepest available layer for the images
    pathZoomIndex: ({layers}) => {
      if(layers){
        return layers.length - 1
      }
      return 1
    },
  },
  onupdate({ changed, current, previous }) {
    if (changed.pointList, changed.layers) {
      this.render();
    }
  },
  methods: {
    render() {
      const {pointList} = this.get();

      if(pointList){

        let lastIcon = {};
        let i = 0;

        let imgList = [];
        pointList.forEach((globalPosPercent) => {
          let thisIcon = this.getIconData({x: globalPosPercent[0], y: globalPosPercent[1]});

          if(thisIcon != lastIcon){
            imgList.push(thisIcon)
            i += 1;
          }
          lastIcon = thisIcon;
        })
        this.set({imgList})
        // console.log(imgList)
      }
    },
    getIconData(globalPosPercent) {
      const {layers, pathZoomIndex} = this.get();
      if(layers && layers[pathZoomIndex]) {

        const gridSelected = {
          // assumes layers is always square
          x: Math.floor(globalPosPercent.x * layers[pathZoomIndex].length),
          y: Math.floor(globalPosPercent.y * layers[pathZoomIndex].length),
        }
      
        if(layers[pathZoomIndex][gridSelected.y] && 
            layers[pathZoomIndex][gridSelected.y][gridSelected.x]
          ){
            const currentIcon = layers[pathZoomIndex][gridSelected.y][gridSelected.x];
            if(currentIcon.num_activations > 0){
              return layers[pathZoomIndex][gridSelected.y][gridSelected.x];
            }
          }
      }
    }
  }
}
</script>

<style>
  .icons {
    margin-top: 8px;
    display: grid;
    grid-auto-flow: column;
  }
</style>