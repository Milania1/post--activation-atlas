<div class="root" bind:clientWidth bind:clientHeight>
  {#if extent}
  <svg width={clientWidth} height={clientHeight}>
    <path
      class="{background ? '' : 'transparent'}"
      on:mousemove="mouseMove(event)"
      on:mouseup="mouseUp(event)"
      d="M0,0 L{clientWidth},0 L{clientWidth},{clientHeight} L0,{clientHeight} z M{left},{top} L{left},{bottom} L{right},{bottom}  L{right},{top} z"
    />
  </svg>
    <div
      class="reticle {round ? 'round' : ''}"
      on:mousemove="mouseMove(event)"
      on:mousedown="mouseDown(event)"
      on:mouseup="mouseUp(event)"
      style="
        border-color: {color};
        top:{top}px;
        left:{left}px; 
        width:{right-left}px; 
        height:{bottom-top}px; 
        "
    >

    {#if annotationValue}
      <div class="annotationTabParent" style="top:{(w * width-2)/2}px;">
        <div class="annotationTab" style="background:{color};">
          <p class="annotation"
            >{annotationValue} 
          </p>
        </div>
      </div>
    {/if}
  </div>
  {/if}
</div>

<script>
  export default {
    data() {
      return {
        dragging: false,
        extent: [[],[]],
        background: true,
        round: false,
        // color: "rgb(255, 130, 0)",
        color: "rgba(100, 100, 100, 0.5)",
        enableDragging: true,
      }
    },
    computed: {
      left: ({clientWidth, extent}) => Math.max(0, extent[0][0] * clientWidth),
      right: ({clientWidth, extent}) => Math.min(clientWidth, extent[0][1] * clientWidth),
      top: ({clientHeight, extent}) => Math.max(0, extent[1][0] * clientHeight),
      bottom: ({clientHeight, extent}) => Math.min(clientHeight, extent[1][1] * clientHeight),
    },
    methods: {
      mouseUp() {
        const { startPos, height, width, scale, aspectRatio, gcx, gcy} = this.get();
        this.set({dragging: false})
      },
      mouseDown(event) {
        const {enableDragging} = this.get();
        if(enableDragging){
          event.preventDefault();
          this.set({dragging: true, startPos: {x: event.screenX, y: event.screenY}})
        }
      },
      mouseMove(event) {
        const {dragging, startPos, scale, width, aspectRatio, height, left, top} = this.get();
        if(dragging){
           this.set({
              gcx: (event.screenX - startPos.x + left) / width + 1 / scale * aspectRatio / 2, 
              gcy: (event.screenY - startPos.y + top) / height + 1 / scale / 2, 
           })
           this.set({
            startPos: {x: event.screenX, y: event.screenY}
           })
        }
      },
    },
  }
</script>

<style>
  svg {
    position: absolute;
    top: 0;
    left: 0;
  }
  svg path {
    fill: white;
    fill-opacity: 0.7;
  }
  svg path.transparent {
    fill-opacity: 0;
  }
  .root {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
  }
  .reticle {
    top: 0;
    left: 0;
    position: absolute;
    border: solid 1px black;
    box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);
    box-sizing: border-box;
    background: rgba(0, 0, 0, 0);
    border-radius: 4px;
  }
  .reticle.round {
    border-radius: 50%;
  }
  .annotationTabParent {
    position: absolute;
    left:0px;
  }
  .annotationTab {
    width: 16px;
    height: 16px;
    left: -16px;
    top: -8px;
    position: absolute;
    border-radius: 3px 0px 0px 3px;
  }
  .annotation {
    font-size: 12px;
    top: -6px;
    left: 4px;
    color: white;
    position: absolute;
    text-align: center;
  }
</style>