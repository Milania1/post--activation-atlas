{
  "version": 3,
  "file": "detail.css",
  "sources": [
    "../../src/components/App.html",
    "../../src/Atlas.html",
    "../../src/components/AppMiniMap.html",
    "../../src/components/AppLayerChooser.html",
    "../../src/components/AppClassFilter.html",
    "../../src/library/Button.html",
    "../../src/library/App/Panel.html",
    "../../src/Zoom.html",
    "../../src/AtlasReticle.html",
    "../../src/library/Placeholder.html",
    "../../src/AtlasThumbnail.html"
  ],
  "sourcesContent": [
    "<div class=\"container\">\n    <div class=\"filter\" style=\"display: {showClassFilter ? 'block' : 'none'};\">\n      <Panel>\n        <h2 slot=\"head\">Class Filter</h2>\n        <div slot=\"body\">\n          <AppClassFilter\n            bind:classHeatmap\n          />\n        </div>\n      </Panel>\n    </div>\n    <div class=\"stack\" style=\"display: {showLayerChooser ? 'block' : 'none'};\">\n      <Panel>\n        <h2 slot=\"head\">Layer</h2>\n        <div slot=\"body\">\n          <AppLayerChooser\n            bind:layerName\n            {classHeatmap}\n          />\n        </div>\n      </Panel>\n    </div>\n  <div class=\"main\">\n    <div class=\"atlas\">\n        <Atlas\n          ref:atlas\n          id=\"inceptionv1_{layerName}\"\n          strokeColor=\"#666\"\n          backgroundColor=\"#dfdfdf\"\n          showHoverImage={false}\n          {scaleCountFactor}\n          {classHeatmap}\n          bind:iconCrop \n          bind:classHeatmapMultiplier\n          bind:classHeatmapPositive\n          bind:gridSize\n          bind:showLabels\n          bind:aspectRatio\n          bind:scale\n          bind:gcx\n          bind:gcy\n          {homeX}\n          {homeY}\n          {homeScale}\n        />\n        <div ref:controls>\n          <div class=\"map\" style=\"display: {scale > 1.0 ? 'block' : 'none'};\">\n            <AppMiniMap \n              id=\"inceptionv1_{layerName}\"\n              {layerName}\n              bind:aspectRatio\n              bind:scale\n              bind:gcx\n              bind:gcy\n              enableDragging={true}\n              {classHeatmap}\n              {scaleCountFactor}\n            />\n          </div>\n          <div class=\"buttons\">\n            <Button on:click=\"refs.atlas.home()\"><Navigation name=\"home\" color=\"white\"/></Button>\n            <Button on:click=\"refs.atlas.zoomit(2)\"><Navigation name=\"add\" color=\"white\"/></Button>\n            <Button on:click=\"refs.atlas.zoomit(0.5)\"><Navigation name=\"remove\" color=\"white\"/></Button>\n          </div>\n          <!-- <label><input type=checkbox bind:checked=showLabels> show labels</label> -->\n        </div>\n    </div>\n  </div>\n  <div class=\"options\" style=\"display: {showOptions ? 'block' : 'none'};\">\n    <Panel>\n      <h2 slot=\"head\">Options</h2>\n      <div slot=\"body\" class=\"options-body\">\n\n        <div>\n          <div>x: {@html format(gcx)}</div>\n          <div>y: {@html format(gcy)}</div>\n          <div>scale: {@html format(scale)}</div>\n        </div>\n        <div>\n        <h3>Attribution</h3>\n          <label><input type=checkbox bind:checked=showLabels> show labels</label>\n        </div>\n        <div class=\"grid-size\">\n          <h3>Grid size</h3>\n          <label><input type=radio bind:group=gridSize value={0}> 20x20</label>\n          <label><input type=radio bind:group=gridSize value={1}> 40x40</label>\n          <label><input type=radio bind:group=gridSize value={2}> 80x80</label>\n          <label><input type=radio bind:group=gridSize value={3}> 160x160</label>\n          <label><input type=radio bind:group=gridSize value={4}> 320x320</label>\n        </div>\n        <div>\n          <h3>Icons</h3>\n          <div>density: {@html iconScaleFactor}</div>\n          <input type=\"range\" min={0.2} max={10} step={0.1} bind:value=iconScaleFactor>\n          <br>\n          <div>crop: {@html iconCrop}</div>\n          <input type=\"range\" min={0} max={0.5} step={0.01} bind:value=iconCrop>\n        </div>\n        <div style=\"display: {classHeatmap > -1 ? 'block' : 'none'}\">\n          <h3>Class filter</h3>\n          <div>Intensity: {@html classHeatmapMultiplier}</div>\n          <input type=\"range\" min=0.5 max=2 step=0.1 bind:value=classHeatmapMultiplier>\n          <label><input type=radio bind:group=classHeatmapPositive value={1}> positive influence</label>\n          <label><input type=radio bind:group=classHeatmapPositive value={-1}> negative influence</label>\n        </div>\n      </div>\n    </Panel>\n  </div>\n</div>\n\n\n<script>\nimport {format as f} from \"d3-format\";\n\nexport default {\n  components: { \n    Button: \"../library/Button.html\",\n    Navigation: \"../library/icons/Navigation.html\",\n    AppMiniMap: \"./AppMiniMap.html\",\n    AppLayerChooser: \"./AppLayerChooser.html\",\n    AppClassFilter: \"./AppClassFilter.html\",\n    Atlas: \"../Atlas.html\",\n    Panel: \"../library/App/Panel.html\"\n  },\n  data() {\n    return {\n      layerName: \"mixed4c\",\n      gridSize: 1,\n      classHeatmap: -1,\n      iconScaleFactor: 0.8,\n      iconCrop: 0.35,\n      showClassFilter: true,\n      showLayerChooser: true,\n      showOptions: true,\n      homeX: .5,\n      homeY: .5,\n      homeScale: 1,\n    }\n  },\n  computed: {\n    realGridSize: ({gridSize}) => (gridSize + 1) * 20,\n    scaleCountFactor: ({iconScaleFactor, realGridSize}) =>  1000000 / (realGridSize * realGridSize * iconScaleFactor)\n  },\n  helpers: {\n    format: f(\".3f\")\n  }\n}\n</script>\n\n<style>\n  .container {\n    height: 100%;\n    box-sizing: border-box;\n    grid-column: screen;\n    display: flex;\n    overflow: hidden;\n    contain: strict;\n    font-size: 12px;\n    position: relative;\n  }\n\n  /*  */\n  .filter {\n    width: 170px;\n    border-right: solid 1px rgba(0, 0, 0, 0.2);\n  }\n  .stack {\n    overflow-y: scroll;\n    width: 170px;\n    border-right: solid 1px rgba(0, 0, 0, 0.2);\n    height: 100%;\n  }\n  .main {\n    flex-grow: 1;\n    padding: 8px;\n    box-sizing: border-box;\n    height: 100%;\n  }\n  .options {\n    width: 170px;\n    border-left: solid 1px rgba(0, 0, 0, 0.2);\n    line-height: 1.5em;\n  }\n  .options-body {\n    padding: 16px;\n  }\n  /*  */\n  ref:controls {\n    position: absolute;\n    right: 16px;\n    top: 16px;\n    display: flex;\n    padding: 8px;\n    background-color: white;\n    border-radius: 6px;\n    border: solid 1px rgba(0, 0, 0, 0.2);\n  }\n  ref:controls .map {\n    width: 104px;\n    margin-right: 8px;\n  }\n  ref:controls .buttons {\n    width: 32px;\n    display: grid;\n    grid-gap: 4px;\n\n  }\n  .options label {\n    display: block;\n  }\n  .atlas {\n    height: calc(100%);\n    position: relative;\n  }\n</style>",
    "<Radar bind:ready />\n\n{#if ready}\n  <AtlasDataLoader \n    {id} \n    {layer} \n    {layout}\n    {classFilter}\n    {filter}\n    bind:config\n    bind:layers \n    bind:labels \n  />\n{/if}\n\n  <div\n    ref:root\n    bind:clientWidth=viewWidth\n    bind:clientHeight=viewHeight\n  >\n    <div\n      ref:stage\n      class=\"{(mouseMoveMode == 'pan' & enableDragToPan) ? 'panning' : ''}\"\n      on:mousedown=\"mouseDown(event)\" on:mousemove=\"mouseMove(event)\" \n      on:mouseenter=\"mouseEnter(event)\" on:mouseout=\"mouseOut(event)\"\n    >\n      <Zoom\n        ref:zoom\n        bind:scale\n        bind:unit\n        bind:gcx\n        bind:gcy\n        width={viewWidth}\n        height={viewHeight}\n      />\n      <canvas\n        ref:canvas\n        width={viewWidth * screenResolution}\n        height={viewHeight * screenResolution}\n        style=\"width: {viewWidth}px; height: {viewHeight}px;\"\n      ></canvas>\n      {#if showHoverIcon}\n        <div class=\"icon\" style=\"width:{iconSizeInPixels + 2 + 'px'}; height:{iconSizeInPixels + 2 + 'px'}; left:{topLeftCornerHover.x + 'px'}; top:{topLeftCornerHover.y + 'px'}\"></div>\n      {/if}\n    </div>\n\n    {#if labels && showHoverIcon && currentIconInfo && currentIconInfo.top_class_indices}\n      <div class=\"hover\" style=\"top: {(topLeftCornerHover.y + iconSizeInPixels + 10) + 'px'}; left: {(topLeftCornerHover.x + iconSizeInPixels + 10) + 'px'}\">\n        <table>\n        {#if classHeatmap > -1}\n          <tr>\n            <!-- <td>{(labels[classHeatmap])}</td> -->\n            <!-- <td style=\"text-align: right;\">{(currentIconInfo.top_class_values[currentIconInfo.top_class_indices.indexOf(classHeatmap)].toPrecision(2))}</td> -->\n          </tr>\n          <tr>\n            <td>top class: {labels[currentIconInfo.top_class_indices[0]]}</td>\n            <td style=\"text-align: right;\">{(currentIconInfo.top_class_values[0].toPrecision(2))}</td>\n          </tr>\n        {:else}\n          {#each currentIconInfo.top_class_indices.slice(0,5) as top, i}\n            <tr>\n              <td style=\"width: 10px; text-align: right; padding-right: 4px;\">{i + 1}.</td>\n              <td class=\"{i == 0 ? 'first': ''}\">{labels[top]}</td>\n              <td style=\"text-align: right;\">{currentIconInfo.top_class_values[i].toPrecision(2)}</td>\n            </tr>\n          {/each}\n        {/if}\n        </table>\n        {#if showHoverImage}\n          <canvas ref:hoverImage></canvas>\n        {/if}\n        <div style=\"font-size: 10px; margin-top: 4px; color: #999; text-align: right;\">Average of {currentIconInfo.num_activations} activations</div>\n      </div>\n    {/if}\n\n  </div>\n\n<script>\nimport { default as load } from './load.js';\nimport { max } from 'd3-array';\n\nexport default {\n  components: { \n    AtlasDataLoader: './AtlasDataLoader.html', \n    Zoom: './Zoom.html',\n    Radar: './library/Radar.html'\n  },\n  data() {\n    return {\n      ready: true,\n      id: \"inceptionv1_mixed4c\",\n      \n      config: null,\n      layers: null,\n      labels: null,\n\n      layer: 0,\n      layout: 0,\n      classFilter: 0,\n      filter: 0,\n\n      minActivations: 1,\n\n      showLabels: false,\n      textShadow: false,\n      showHoverImage: false,\n\n      context: null,\n\n      alphaAttributionFactor: 0.02,\n      scaleCountFactor: 1,\n      classHeatmap: -1,\n      classHeatmapMultiplier: 1,\n      classHeatmapPositive: 1,\n\n      gridSize: null,\n      showGrid: false,\n\n      // for initial state, and going back to \"home\"\n      homeX: .5,\n      homeY: .5,\n      homeScale: 1,\n\n      iconCrop: 0.02,\n\n      // zoom factor\n      zoomFactors: {out: 0.5, in: 2},\n\n      // turn off features\n      enableClickToZoom: true,\n      enableHover: true,\n      enableDragToPan: true,\n\n\n      backgroundColor: \"white\",\n      strokeColor: \"rgb(220, 220, 220)\",\n      strokeThickness: 1,\n      imageSmoothing: false,\n      fontSize: 10,\n      textColor: \"white\",\n      textShadowColor: \"rgba(0, 0, 0, 0.8)\",\n\n      // for positioning the hover icon\n      lastRecordedCanvasPos: {x: -100, y: -100},\n\n      // for managing panning off the screen\n      mouseDownScreenPos: {x: 0, y: 0},\n\n      // can be \"hover\" or \"pan\"\n      mouseMoveMode: 'hover',\n      onCanvas: false,\n\n      screenResolution: 1,\n\n      mouseDownTimer: 0,\n      mouseMoveFunction: function(){},\n      mouseUpFunction: function(){},\n\n    }\n  },\n  computed: {\n    maxAttributionValue: ({layers, layer}) => {\n      // return 0.25;\n      if (layers == null) return 0;\n      const l = layers[layer];\n      let max = 0;\n      l.forEach(x => {\n        x.forEach(y => {\n          if (y && y.num_activations > 500) {\n            const v = y.full_class_values[0];\n            if (v > max) max = v;\n          }\n        })\n      })\n      return max;\n      // return layers ? max(l, d => d ? max(d, dd => dd ? (dd.n > 50 ? (dd.top_class_values[dd.top_class_indices.indexOf(classHeatmap)]) : 0) : 0): 0) : 0;\n      },\n    aspectRatio: ({viewWidth, viewHeight}) => viewWidth / viewHeight,\n    // viewHeight: ({viewWidth}) => viewWidth / 1.5,\n    // Math.min of viewHeight/viewWidth to make sure it fits inside when scale = 1\n    minViewDimInPx: ({viewWidth, viewHeight}) => Math.min(viewWidth, viewHeight), \n    // defines top left corner of global in pixels, relative to the upper left corner of the canvas as 0,0\n    topLeft: ({gcx, gcy, scale, viewWidth, viewHeight, minViewDimInPx}) => {\n      return {\n        x: viewWidth / 2 - gcx * minViewDimInPx * scale,\n        y: viewHeight / 2 - gcy * minViewDimInPx * scale} \n    },\n    currentZoomIndex: ({scale, gridSize}) => {\n      let s = 0;\n      if (gridSize != null) {\n        s = gridSize;\n      } else {\n        if (scale > 1) s = 0;\n        if (scale > 2) s = 1;\n        if (scale > 4) s = 2;\n        if (scale > 8) s = 3;\n        if (scale > 16) s = 4;\n      }\n      return +s;\n    },\n    numIconsWide: ({currentZoomIndex, layers}) => {\n      if(layers && currentZoomIndex){\n        return layers[currentZoomIndex].length\n      }\n    },\n    iconSizeInPixels: ({config, minViewDimInPx, currentZoomIndex, scale}) => {\n      if(config){\n        return minViewDimInPx / (config.grid_size[currentZoomIndex]) * scale;\n      }\n    },\n    showHoverIcon: ({mouseMoveMode, onCanvas, currentIconInfo, enableHover}) => {\n      return enableHover && onCanvas && (mouseMoveMode == 'hover') && currentIconInfo\n    },\n    layerScale: ({minViewDimInPx, config, currentZoomIndex, scale}) => {\n      if(config){\n        return (minViewDimInPx / (config.icon_size * config.grid_size[currentZoomIndex])) * scale\n      }\n    }, \n    gridSelected: ({lastRecordedCanvasPos, topLeft, layerScale, config}) => {\n      if(config){\n        return {\n          x: Math.floor((lastRecordedCanvasPos.x - topLeft.x) / (layerScale * config.icon_size)),\n          y: Math.floor((lastRecordedCanvasPos.y - topLeft.y) / (layerScale * config.icon_size))\n        }        \n      }\n    }, \n    topLeftCornerHover: ({config, layerScale, topLeft, gridSelected}) => {\n      if(config){\n        return {\n          x: gridSelected.x * config.icon_size * layerScale + topLeft.x - 1,\n          y: gridSelected.y * config.icon_size * layerScale + topLeft.y - 1\n        }\n      }\n    },\n    currentIconInfo: ({layers, currentZoomIndex, gridSelected, classHeatmap}) => {\n      if(layers && layers[currentZoomIndex] && \n         layers[currentZoomIndex][gridSelected.y] && \n         layers[currentZoomIndex][gridSelected.y][gridSelected.x]\n         ){\n          const iconInfo = layers[currentZoomIndex][gridSelected.y][gridSelected.x];\n          if(iconInfo.num_activations > 0){\n            return iconInfo\n          }\n      }\n    }\n  },\n  onupdate({ changed, current, previous }) {\n    this.set({context: this.refs.canvas.getContext('2d')});\n    if (changed.maxAttributionValue || changed.minActivations || changed.classHeatmap || changed.classHeatmapMultiplier || changed.classHeatmapPositive || changed.labels || changed.showLabels || changed.viewWidth || changed.viewHeight || changed.scale || changed.iconCrop || changed.currentZoomIndex || changed.layers || changed.alphaAttributionFactor || changed.scaleCountFactor || changed.gcx || changed.gcy) {\n      this.render();\n    }\n    if (changed.currentIconInfo) {\n      this.updateIconHoverImage();\n    }\n\n  },\n  oncreate() {\n    this.home();\n  },\n  methods: {\n    fullscreen() {\n      this.refs.root.webkitRequestFullscreen();\n    },\n    mouseEnter() {\n      this.set({onCanvas: true})\n    },\n    mouseDown(event) {\n      // should this be set once, somewhere else? oncreate? \n      this.set({mouseMoveFunction: this.mouseMove.bind(this), mouseUpFunction: this.mouseUp.bind(this)});\n\n      const {mouseMoveFunction, mouseUpFunction} = this.get();\n\n      event.preventDefault();\n\n      // set event listeners on window\n      window.addEventListener(\"mousemove\", mouseMoveFunction);\n      window.addEventListener(\"mouseup\",mouseUpFunction);\n      // do I need to unset local listener? \n\n      this.set({mouseMoveMode: 'pan'})\n      this.set({mouseDownTimer: Date.now()})\n\n      // canvas position\n      this.set({lastRecordedCanvasPos: {x: event.offsetX, y: event.offsetY}})\n\n      // screenPosition at mousedown\n      this.set({mouseDownScreenPos: {x: event.screenX, y: event.screenY}})\n\n    },\n    mouseMove(event) {\n      const { mouseMoveMode } = this.get();\n\n      this.set({lastRecordedCanvasPos: {x: event.offsetX, y: event.offsetY}});\n\n      if (mouseMoveMode == 'pan') {\n        const {mouseDownScreenPos, gcx, gcy, enableDragToPan} = this.get();\n\n        // update gcx, gcy, mouseDownScreenPos\n        this.set({\n          mouseDownScreenPos: {x: event.screenX, y: event.screenY}\n        })\n\n        if(enableDragToPan){\n          this.refs.zoom.panTo(\n            this.toPercent(mouseDownScreenPos.x - event.screenX) + gcx,\n            this.toPercent(mouseDownScreenPos.y - event.screenY) + gcy,\n            0\n          )\n        } \n      }\n\n    },\n    mouseOut(event) {\n      this.set({\n        onCanvas: false\n      });\n    },\n    mouseUp(event) {\n      const {mouseDownTimer, mouseMoveMode, scale, zoomFactors, mouseMoveFunction, mouseUpFunction, lastRecordedCanvasPos, topLeft, gcx, gcy, enableClickToZoom} = this.get();\n\n      // reset mode to hover\n      this.set({mouseMoveMode: 'hover'})\n\n      // remove body event listeners\n      window.removeEventListener(\"mousemove\", mouseMoveFunction);\n      window.removeEventListener(\"mouseup\", mouseUpFunction);\n\n      // calculate offsets to determine to zoom or not\n      const clickDiff = (Date.now() - mouseDownTimer);\n      const clickDistance = Math.sqrt(\n        Math.pow(event.offsetX - lastRecordedCanvasPos.x, 2) + \n        Math.pow(event.offsetY - lastRecordedCanvasPos.y, 2)\n        );\n\n\n      // 200ms and 5 pixels distance is fairly arbitrary\n      if(clickDiff < 200 && clickDistance < 5) {\n        // ZOOM!\n        if(enableClickToZoom){\n          // use shift key to determine to zoom in or zoom out\n          let zoomBy = zoomFactors.in;\n          if(event.shiftKey){\n            zoomBy = zoomFactors.out;\n          }\n\n          let newCenter = {x: 0.5, y: 0.5}\n\n          // go home if scale < 1\n          let newScale = zoomBy * scale;\n          if(newScale > 1){\n            // use current mouse position to find new center position\n            const fixedPoint = {\n              x: this.toPercent(event.offsetX - topLeft.x),\n              y: this.toPercent(event.offsetY - topLeft.y)\n            }\n            newCenter = {\n              x: fixedPoint.x - ((fixedPoint.x - gcx)/zoomBy),\n              y: fixedPoint.y - ((fixedPoint.y - gcy)/zoomBy)\n            }\n          } else {\n            newScale = 1;\n          }\n          this.transitionTo(newCenter.x, newCenter.y, newScale, 500)\n        }\n      }\n    },\n    home() {\n      const {homeX, homeY, homeScale} = this.get();\n      this.transitionTo(homeX,homeY,homeScale,800)\n    },\n    transitionTo(x, y, scale, duration) {\n      this.refs.zoom.transitionTo(x,y,scale,duration);\n    },\n    zoomit(multiplier) {\n      const { scale } = this.get();\n      this.refs.zoom.scaleTo(scale * multiplier, 500)\n    },\n    iconToCanvasPosition(icon, layerIndex) {\n      const {config, scaleCountFactor, topLeft, layerScale, currentZoomIndex} = this.get();\n\n      const proportionalScaleCountFactor = scaleCountFactor / (currentZoomIndex + 1)\n      const scaleModifier = (Math.sqrt(Math.min(proportionalScaleCountFactor, icon.num_activations) / proportionalScaleCountFactor)) \n      const iconWidth = config.icon_size * layerScale * scaleModifier;\n\n      const sx = icon.localX * config.icon_size;\n      const sy = icon.localY * config.icon_size;\n\n      const tilePos_x = icon.grid_y * config.icon_size;\n      const tilePos_y = icon.grid_x * config.icon_size;\n\n      // pixel coordinate in the global coordinate space\n      const globalPixelPos_x = tilePos_x * layerScale;\n      const globalPixelPos_y = tilePos_y * layerScale;\n\n      const canvasPos_x = globalPixelPos_x + topLeft.x;\n      const canvasPos_y = globalPixelPos_y + topLeft.y;      \n\n      // calc scale adjust factor to center the image for the icon in it's box\n      const scaleAdjustFactor =  (1 - scaleModifier) * config.icon_size * layerScale  / 2;\n\n      const dx = canvasPos_x + scaleAdjustFactor;\n      const dy = canvasPos_y + scaleAdjustFactor;\n\n      return {sx, sy, dx, dy, iconWidth}\n    },\n    toPercent(p) {\n      const {scale, minViewDimInPx} = this.get();\n      return p / (scale * minViewDimInPx);\n    },\n    toPixels(p) {\n      const {scale, minViewDimInPx} = this.get();\n      return p * scale * minViewDimInPx;\n    },\n    clear() {\n      const {viewHeight, viewWidth, context, backgroundColor} = this.get();\n      context.globalAlpha = 1;\n      context.fillStyle= backgroundColor;\n      context.clearRect(0, 0, viewWidth, viewHeight);\n      context.fillRect(0, 0, viewWidth, viewHeight);\n    },\n    updateIconHoverImage() {\n      const {currentIconInfo, currentZoomIndex, iconCrop, config, showHoverImage} = this.get();\n      if(currentIconInfo && showHoverImage){\n        load(currentIconInfo.url).then(response => {\n          const hoverImageContext = this.refs.hoverImage.getContext('2d');\n          const {sx, sy, dx, dy, iconWidth} = this.iconToCanvasPosition(currentIconInfo, currentZoomIndex)\n          const iconOffset = (iconCrop * config.icon_size) / 2;\n          const edgeLength = Math.min(this.refs.hoverImage.height, this.refs.hoverImage.width)\n          hoverImageContext.drawImage(response,\n                          //source\n                          sy + iconOffset, sx + iconOffset, config.icon_size - iconOffset * 2, config.icon_size - iconOffset * 2,\n                          //destination\n                          0, 0, edgeLength, edgeLength\n                        );\n        })\n      }\n    },\n    render() {\n\n      const {imageSmoothing, minActivations, viewHeight, viewWidth, context, backgroundColor, config, layers, currentZoomIndex, strokeColor, strokeThickness, fontSize,textShadowColor, textColor, maxAttributionValue, classHeatmapMultiplier} = this.get();\n\n      this.clear();\n      // context.imageSmoothingQuality = \"low\";\n      context.imageSmoothingEnabled = imageSmoothing;\n\n      if (config && layers) {\n        layers.forEach((icons, layerIndex) => {\n          const visibleLayers = [currentZoomIndex]\n\n          if (visibleLayers.indexOf(layerIndex) > -1) {\n\n            icons.forEach((columns, x) => {\n              columns.forEach((icon, y) => {\n                if (icon.num_activations >= minActivations) {\n\n                  const {dx, dy, iconWidth} = this.iconToCanvasPosition(icon, layerIndex);\n\n                  // If icon is in the viewport\n                  if (dx > -iconWidth && dx < viewWidth && dy > -iconWidth && dy < viewHeight) {\n                    \n                    // We want to draw a box before the icon has loaded so there isn't just whiteness.\n                    const {sx, sy, dx, dy, iconWidth} = this.iconToCanvasPosition(icon, layerIndex)\n                    context.globalAlpha = 0.75;\n                    context.strokeStyle = strokeColor;\n                    context.lineWidth = strokeThickness;\n                    context.fillStyle = \"white\";\n                    context.beginPath();\n                    context.rect(dx, dy, iconWidth, iconWidth);\n                    context.stroke();\n                    context.fill();\n                    context.closePath();\n\n                    load(icon.url).then(response => {\n                      // check that we're still on the right layer/zoom\n                      const {currentZoomIndex, iconCrop, showLabels, textShadow} = this.get();\n                      if(currentZoomIndex == layerIndex) {\n                        const {alphaAttributionFactor, labels, config, classHeatmap, classHeatmapMultiplier, classHeatmapPositive} = this.get();\n\n                        let a = 1;\n                        if (classHeatmap > -1) {\n                          let i = icon.full_class_indices.indexOf(classHeatmap);\n                          if (i > -1) {\n                            a = icon.full_class_values[i] / maxAttributionValue;\n                            a = a * classHeatmapPositive;\n                            a = Math.max(0, a) * classHeatmapMultiplier;\n                          } else {\n                            a = 0.0;\n                          }\n                        }\n                        // let a = Math.min(1,\n                        //   Math.max(0.2, Math.pow(icon.top_class_values[0], 2) * \n                        //   1000 * alphaAttributionFactor));\n\n                        // get current values in case they changed while loading\n                        const {sx, sy, dx, dy, iconWidth} = this.iconToCanvasPosition(icon, layerIndex)\n\n                        // draw the icon\n                        context.globalAlpha = a;\n                        const iconOffset = (iconCrop * config.icon_size) / 2;\n                        context.clearRect(dx + 1, dy + 1, iconWidth - 2, iconWidth - 2);\n                        context.drawImage(response,\n                          //source\n                          sy + iconOffset, sx + iconOffset, config.icon_size - iconOffset * 2, config.icon_size - iconOffset * 2,\n                          //destination\n                          dx, dy, iconWidth, iconWidth\n                        );\n                        context.globalAlpha = 1;\n\n                        if (showLabels && labels) {\n                          context.globalAlpha = 1;\n                          context.font=fontSize + \"px Helvetica\";\n                          if (textShadow) {\n                            context.lineWidth = 2;\n                            context.strokeStyle = textShadowColor;\n                            context.strokeText(labels[icon.top_class_indices[0]], dx + 4, dy + iconWidth - 4, iconWidth - 8);\n                          }\n                          context.fillStyle = textColor;\n                          context.fillText(labels[icon.top_class_indices[0]], dx + 4, dy + iconWidth - 4, iconWidth - 8);\n                        }\n\n                      }\n\n                    })\n                  }\n                }\n              })\n            })\n          }\n        })\n      }\n    }\n    }\n  }\n\n</script>\n\n\n<style>\n  ref:root {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    contain: layout;\n  }\n  ref:stage {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n  ref:stage.panning {\n    cursor: move;\n  }\n  ref:canvas {\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 8px;\n  }\n  .hover {\n    color: white;\n    position: absolute;\n    font-size: 12px;\n    line-height: 14px;\n    background: rgba(0, 0, 0, 0.8);\n    padding: 6px;\n    pointer-events: none;\n    border-radius: 0 8px 8px 8px;\n    border: solid 1px rgba(255, 255, 255, 0.4);\n    box-sizing: border-box;\n    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n    width: 200px;\n    z-index: 10000;\n  }\n  .hover table {\n    width: 100%;\n    margin-bottom: 0;\n  }\n  .hover td {\n    font-size: 12px;\n    border-bottom: solid 1px rgba(255, 255, 255, 0.2);\n    padding: 6px 0;\n    margin: 6px 0;\n    color: rgba(255, 255, 255, 0.8);\n    overflow: ellipsis;\n  }\n  .hover td.first {\n    color: rgba(255, 255, 255, 1.0);\n    font-weight: bold;\n  }\n\n  .icon {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 4px;\n    border: solid 3px black;\n    pointer-events: none;\n    box-sizing: border-box;\n  }\n</style>",
    "<div ref:root>\n  <Placeholder>\n    <Atlas \n      ref:overview\n      {id}\n      {classHeatmap}\n      gridSize={1} \n      iconCrop={0.6} \n      {scaleCountFactor}\n      backgroundColor=\"#f0f0f0\"\n    />\n    <!-- <AtlasThumbnail \n      {layerName}\n    /> -->\n    <AtlasReticle\n      bind:aspectRatio\n      bind:scale\n      bind:gcx\n      bind:gcy\n      enableDragging={true}\n    />\n  </Placeholder>\n</div>\n\n<script>\n  export default {\n    components: {\n      Atlas: \"../Atlas.html\",\n      AtlasReticle: \"../AtlasReticle.html\",\n      Placeholder: \"../library/Placeholder.html\"\n    },\n    data() {\n      return {\n        scaleCountFactor: 200\n      }\n    }\n  }\n</script>\n\n<style>\nref:root {\n  position: relative;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n</style>",
    "<div class=\"stack\">\n{#each layers as layer, i}\n  <label class=\"layer {layerName == layer ? 'selected' : ''}\">\n    <input type=radio bind:group=layerName value={layer}>\n    <div style=\"width: 50px; position: relative;\">\n      <AtlasThumbnail layerName={layer} {classHeatmap}/>\n    </div>\n    <span>{layer}</span>\n  </label>\n{/each}\n</div>\n\n<script>\n  export default {\n    components: {\n      AtlasThumbnail: \"../AtlasThumbnail.html\"\n    },\n    data() { return {\n      layerName: \"mixed4c\",\n      layers: [\n        \"mixed3b\",\n        \"mixed4a\",\n        \"mixed4b\",\n        \"mixed4c\",\n        \"mixed4d\",\n        \"mixed4e\",\n        \"mixed5a\",\n        \"mixed5b\",\n      ],\n      classHeatmap: -1\n    }; }\n  }\n</script>\n\n<style>\n.layer {\n  position: relative;\n  cursor: pointer;\n  display: grid;\n  align-items: center;\n  grid-template-columns: 1fr 1.5fr;\n  font-size: 11px;\n  text-transform: uppercase;\n  padding: 5px 16px 5px 16px;\n  color: grey;\n  border-left: solid 3px rgba(255, 255, 255, 0);\n  border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n}\n.layer input {\n  position: absolute;\n  opacity: 0;\n}\n.layer span {\n  margin-left: 8px;\n}\n.layer.selected {\n  border-left-color: rgb(255, 130, 0);\n  color: rgb(255, 130, 0);\n  background-color: rgba(255, 130, 0, 0.08);\n  font-weight: bold;\n}\n.layer :global(canvas) {\n  opacity: 0.5;\n}\n.layer.selected :global(canvas) {\n  /* opacity: 1; */\n}\n</style>",
    "<div class=\"chooser\">\n  {#each labels as l}\n    <label class=\"{classHeatmap === l.i ? 'selected' : ''}\">\n      <input type=radio bind:group=classHeatmap value={l.i}>\n      <span title=\"{l.i}\">{l.label}</span>\n    </label>\n  {/each}\n</div>\n\n<script>\nimport classesToKeep from './../classesToKeep.js';\nimport inceptionLabels from './../Labels.js';\n\nexport default {\n  data() {\n    return {\n      classesToKeep,\n      inceptionLabels,\n      classHeatmap: 235\n    }\n  },\n  computed: {\n    labels: ({inceptionLabels}) => {\n      let out = classesToKeep.map(k => {\n        let l = inceptionLabels.inception[k];\n        return {label: l, i: k};\n      });\n      return [{label: \"show all\", i: -1}].concat(out);\n    }\n  }\n}\n</script>\n\n<style>\n  .chooser {\n    height: auto;\n  }\n  .chooser label {\n    position: relative;\n    font-size: 11px;\n    line-height: 1.2em;\n    display: block;\n    border-left: solid 3px white;\n    padding: 5px 16px 5px 16px;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-y: hidden;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n  }\n  .chooser label input {\n    position: absolute;\n    opacity: 0;\n  }\n  .chooser label.selected {\n    border-left-color: rgb(255, 130, 0);\n    color: rgb(255, 130, 0);\n    background-color: rgba(255, 130, 0, 0.08);\n    font-weight: bold;\n  }\n</style>",
    "<button\n  on:click=\"fire('click')\"\n>\n  <slot></slot>\n</button>\n\n<script>\nexport default {\n\n}\n\n</script>\n\n<style>\n  button {\n    /* border: solid 2px rgb(255, 130, 0); */\n    outline: none;\n    font-size: 13px;\n    border: none;\n    color: white;\n    padding: 0 4px;\n    background-color: rgb(255, 130, 0);\n    font-weight: 500;\n    height: 32px;\n    line-height: 1em;\n    border-radius: 4px;\n    text-transform: uppercase;\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    vertical-align: middle;\n    -webkit-font-smoothing: antialiased;\n  }\n</style>",
    "<div class=\"root\">\n  <div class=\"head\">\n    <slot name=\"head\"></slot>\n  </div>\n  <div class=\"body\">\n    <slot name=\"body\"></slot>\n  </div>\n</div>\n\n<style>\n  .root {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n  }\n  :global() .head {\n    height: 60px;\n    padding: 0 16px;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.2);\n    /* box-sizing: border-box; */\n    display: flex;\n    align-items: center;\n    flex: 0 0 60px;\n  }\n  :global() .head h2 {\n    font-size: 16px;\n    font-weight: bold;\n    line-height: 1.4em;\n    margin: 0;\n    padding: 0;\n    border: none;\n  }\n  :global() .body {\n    position: relative;\n    flex: 1;\n    overflow-y: scroll;\n    font-size: 11px;\n    line-height: 1.6em;\n  }\n  :global() .body h3 {\n    font-size: 12px;\n    font-weight: 600;\n    line-height: 1.2em;\n    text-transform: uppercase;\n    margin: 8px 0;\n    height: auto;\n    border-top: solid 1px rgba(0, 0, 0, 0.1);\n    padding-top: 1em;\n  }\n</style>",
    "<div ref:capture>\n<!-- <p style=\"position: absolute; left: 0; right: 0;\">x: {x} y: {y} scale: {scale}</p> -->\n\n</div>\n\n\n<script>\n// import {zoom as d3zoom} from 'd3-zoom';\n// import {event as d3event, select as d3select} from 'd3-selection';\nimport { tween } from 'svelte-extras';\nimport * as eases from 'eases-jsnext';\n\nexport default {\n  data() {\n    return {\n      width: 100,\n      height: 100,\n      gcx: 0.5,\n      gcy: 0.5,\n      scx: 0.5,\n      scy: 0.5,\n      unit: 100,\n\n      //tweenTarget: {\n      //  scale: null, gcx: null, gcy: null\n      //}\n    }\n  },\n  computed: {\n    //translateX: ({gcx, scx, scale, width}) =>  scx * width - gcx * scale * width,\n    //translateY: ({gcy, scy, scale, height}) => scy * height - gcy * scale * height,\n    //transformString: ({translateX, translateY, scale}) => `translate(${translateX},${translateY})scale(${scale})`,\n    scale: ({width, unit}) => {\n      return width / unit\n    }\n  },\n  oncreate() {\n  },\n  methods: {\n    tween,\n    setScale(scale) {\n      const {width} = this.get();\n      this.set({'unit': width / scale})\n    },\n    panTo(newgcx, newgcy, duration) {\n      if (duration === undefined) duration = 1000;\n      if(duration == 0) {\n        this.set({gcx: newgcx, gcy: newgcy})\n      } else {\n        this.tween('gcx', newgcx, {duration, easing: eases.cubicInOut})\n        this.tween('gcy', newgcy, {duration, easing: eases.cubicInOut})\n      }\n    },\n    scaleTo(newScale, duration) {\n      if (duration === undefined) duration = 1000;\n      const {width} = this.get();\n      this.tween('unit', width / newScale, {duration, easing: eases.cubicInOut})\n    },\n    transitionTo(newgcx, newgcy, newScale, duration) {\n      if (duration === undefined) duration = 1000;\n      const {width} = this.get();\n      const newUnit = width / newScale;\n      this.tween('unit', newUnit, {duration, easing: eases.cubicInOut})\n      this.tween('gcx', newgcx, {duration, easing: eases.cubicInOut})\n      this.tween('gcy', newgcy, {duration, easing: eases.cubicInOut})\n    },\n  }\n}\n</script>\n\n<style>\nref:capture {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0);\n  box-sizing: border-box;\n}\n</style>",
    "<div class=\"root\" bind:clientWidth=\"width\" bind:clientHeight=\"height\">\n  {#if scale}\n  <svg {width} {height}>\n    <path\n      class=\"{background ? '' : 'transparent'}\"\n      on:mousemove=\"mouseMove(event)\"\n      on:mouseup=\"mouseUp(event)\"\n      d=\"M0,0 L{width},0 L{width},{height} L0,{height} z M{left},{top} L{left},{bottom} L{right},{bottom}  L{right},{top} z\"\n    />\n  </svg>\n  <div\n    class=\"reticle {round ? 'round' : ''}\"\n    on:mousemove=\"mouseMove(event)\"\n    on:mousedown=\"mouseDown(event)\"\n    on:mouseup=\"mouseUp(event)\"\n    style=\"box-sizing:content-box;\n      border-color: {color};\n      top:{top-2.5}px;\n      left:{left-2.5}px; \n      width:{(right-left-1)}px; \n      height:{(bottom-top-1)}px; \n      cursor:{enableDragging ? 'move' : 'default'}\n      \"\n  >\n    {#if annotationValue}\n      <div class=\"annotationTabParent\" style=\"top:{(w * width-2)/2}px;\">\n        <div class=\"annotationTab\" style=\"background:{color};\">\n          <p class=\"annotation\"\n            >{annotationValue} \n          </p>\n        </div>\n      </div>\n    {/if}\n  </div>\n  {/if}\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        width: 0,\n        height: 0,\n        dragging: false,\n        startPos: {x: -100, y: -100},\n        background: true,\n        round: false,\n        color: \"#ff6600\",\n        enableDragging: true,\n      }\n    },\n    computed: {\n      h: ({scale}) => 1 / scale,\n      w: ({scale, aspectRatio}) => 1 / scale * aspectRatio,\n      l: ({gcx, w, width}) => (gcx - w / 2),\n      t: ({gcy, h, height, aspectRatio}) => (gcy - h / 2),\n      r: ({l, w}) => l + w, \n      b: ({t, h}) => t + h,\n      left: ({l, width, gcx, gcy, scale, aspectRatio, w, r}) => l * width,\n      right: ({r, width}) => r * width,\n      top: ({t, height}) => t * height,\n      bottom: ({b, height}) => b * height,\n    },\n    methods: {\n      mouseUp() {\n        const { startPos, height, width, scale, aspectRatio, gcx, gcy} = this.get();\n        this.set({dragging: false})\n      },\n      mouseDown(event) {\n        const {enableDragging} = this.get();\n        if(enableDragging){\n          event.preventDefault();\n          this.set({dragging: true, startPos: {x: event.screenX, y: event.screenY}})\n        }\n      },\n      mouseMove(event) {\n        const {dragging, startPos, scale, width, aspectRatio, height, left, top} = this.get();\n        if(dragging){\n           this.set({\n              gcx: (event.screenX - startPos.x + left) / width + 1 / scale * aspectRatio / 2, \n              gcy: (event.screenY - startPos.y + top) / height + 1 / scale / 2, \n           })\n           this.set({\n            startPos: {x: event.screenX, y: event.screenY}\n           })\n        }\n      },\n    },\n  }\n</script>\n\n<style>\n  svg {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n  svg path {\n    fill: white;\n    fill-opacity: 0.5;\n  }\n  svg path.transparent {\n    fill-opacity: 0;\n  }\n  .root {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n  }\n  .reticle {\n    top: 0;\n    left: 0;\n    position: absolute;\n    border: solid 3px black;\n    border-radius: 3px;\n    box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);\n    box-sizing: border-box;\n    background: rgba(0, 0, 0, 0);\n  }\n  .reticle.round {\n    border-radius: 50%;\n  }\n  .annotationTabParent {\n    position: absolute;\n    left:0px;\n  }\n  .annotationTab {\n    width: 16px;\n    height: 16px;\n    left: -16px;\n    top: -8px;\n    position: absolute;\n    border-radius: 3px 0px 0px 3px;\n  }\n  .annotation {\n    font-size: 12px;\n    top: -6px;\n    left: 4px;\n    color: white;\n    position: absolute;\n    text-align: center;\n  }\n</style>",
    "<div class=\"root\" bind:clientWidth style=\"display: {display}; padding-bottom: {100 / aspectRatio}%\">\n  <div class=\"container\">\n    <slot></slot>\n  </div>\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        display: \"block\",\n        aspectRatio: 1,\n        clientWidth: 0,\n        \n      }\n    },\n    computed: {\n      width: ({clientWidth}) => clientWidth,\n      height: ({width, aspectRatio}) => width / aspectRatio\n    }\n  }\n</script>\n\n<style>\n.root {\n  position: relative;\n  box-sizing: border-box;\n}\n.container {\n  position: absolute;\n  box-sizing: border-box;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n</style>",
    "\n<div bind:clientWidth style=\"height: {height}px;\">\n  <canvas ref:canvas width={gridSize} height={gridSize} style=\"width: {clientWidth}px; height: {height}px;\"></canvas>\n</div>\n\n<script>\nimport { load } from 'lucid-components';\nimport classesToKeep from './classesToKeep.js';\n\nexport default {\n  data() {\n    return {\n      root: \"https://storage.googleapis.com/activation-atlas/build\",\n      model: \"inceptionv1\",\n      layerName: \"mixed4d\",\n      grid: 1,\n      layout: 0,\n      gridSize: 10,\n      classHeatmap: -1,\n      icons: []\n    };\n  },\n  computed: {\n    height: ({clientWidth}) => clientWidth,\n    id: ({model, layerName}) => model + \"_\" + layerName\n  },\n  oncreate() {\n    const {root, id, grid} = this.get();\n    load(`${root}/${id}/${id}.json`).then(config => {\n      // console.log(\"config: \", config)\n      if (config.class_filter == null) { config.class_filter = \"None\" }\n      if (config.filter == null) { config.filter = \"None\" }\n      if (!Array.isArray(config.layout)) {config.layout = [config.layout]}\n      if (!Array.isArray(config.layer)) {config.layer = [config.layer]}\n      if (!Array.isArray(config.filter)) {config.filter = [config.filter]}\n      this.set({gridSize: config.grid_size[grid]})\n      const url = `${root}/${id}/web/web--grid_size=${config.grid_size[grid]}--layout=${config.layout[0]}--class_filter=${config.class_filter}--filter=${config.filter[0]}--layer=${config.layer[0]}--model=${config.model}--sample_images=${config.sample_images}--sample_type=${config.sample_type}.json`\n      // console.log(\"config\", config)\n      load(url).then(web => {\n        // console.log(\"web\", web)\n        this.set({icons: web});\n        this.render();\n      })\n    })\n  },\n  onupdate({changed}) {\n    if (changed.classHeatmap) {\n      this.render();\n    }\n  },\n  methods: {\n    render() {\n      const {gridSize, icons, classHeatmap} = this.get();\n      const context = this.refs.canvas.getContext('2d');\n      let imageData = context.getImageData(0, 0, gridSize, gridSize);\n      let data = imageData.data;\n      // for (var i = 0; i < data.length; i += 4) {\n        // data[i] = 100;\n        // data[i + 1] = 100;\n        // data[i + 2] = 100;\n        // data[i + 3] = 255;\n      // }\n      for (const icon of icons) {\n        let heatmapMultiplier = 0.5;\n        if (classHeatmap > -1) {\n          let ci = classesToKeep.indexOf(classHeatmap);\n          let value = Math.max(0, icon.f[ci]);\n          heatmapMultiplier = Math.max(0.05, value * 5);\n          // console.log(ci, value)\n        }\n        const y = icon.x; //x,y switched on purpose \n        const x = icon.y; //x,y switched on purpose\n        // data[y * gridSize * 4 + x * 4 + 0] = (heatmapMultiplier) * 255 * 20;\n        // data[y * gridSize * 4 + x * 4 + 1] = (heatmapMultiplier) * 130 * 20;\n        // data[y * gridSize * 4 + x * 4 + 2] = (heatmapMultiplier) * 1 * 20;\n        data[y * gridSize * 4 + x * 4 + 3] = icon.n * heatmapMultiplier;\n      }\n      \n      context.putImageData(imageData, 0, 0);\n    }\n  }\n}\n\n\n</script>\n<style>\ncanvas {\n  image-rendering: pixelated;\n}\n</style>"
  ],
  "names": [],
  "mappings": "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"
}