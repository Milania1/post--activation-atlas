{
  "version": 3,
  "file": "detail.css",
  "sources": [
    "../../src/components/App.html",
    "../../src/components/AtlasTooltip.html",
    "../../src/library/Tooltip.html",
    "../../src/Atlas.html",
    "../../src/library/Button.html",
    "../../src/components/AppMiniMap.html",
    "../../src/components/AppLayerChooser.html",
    "../../src/components/AppClassFilter.html",
    "../../src/library/App/Panel.html",
    "../../src/library/D3Zoom.html",
    "../../src/AtlasReticle.html",
    "../../src/library/Placeholder.html",
    "../../src/AtlasThumbnail.html"
  ],
  "sourcesContent": [
    "<div class=\"container\">\n    <div class=\"filter\" style=\"display: {showClassFilter ? 'block' : 'none'};\">\n      <Panel>\n        <h2 slot=\"head\">Class Filter</h2>\n        <div slot=\"body\">\n          <AppClassFilter\n            bind:classHeatmap\n          />\n        </div>\n      </Panel>\n    </div>\n    <div class=\"stack\" style=\"display: {showLayerChooser ? 'block' : 'none'};\">\n      <Panel>\n        <h2 slot=\"head\">Layer</h2>\n        <div slot=\"body\">\n          <AppLayerChooser\n            bind:layerName\n            {classHeatmap}\n          />\n        </div>\n      </Panel>\n    </div>\n  <div class=\"main\">\n    <div class=\"atlas\">\n        <Atlas\n          ref:atlas\n          id=\"inceptionv1_{layerName}\"\n          strokeColor=\"#666\"\n          backgroundColor=\"#dfdfdf\"\n          showHoverImage={false}\n          bind:density\n          {classHeatmap}\n          bind:iconCrop \n          bind:classHeatmapMultiplier\n          bind:classHeatmapPositive\n          bind:autoGridSizeMultiplier\n          bind:gridSize\n          bind:showLabels\n          bind:scale\n          bind:aspectRatio\n          bind:gcx\n          bind:gcy\n          bind:extent\n          bind:scrollWheel=\"$scroll\"\n          {homeX}\n          {homeY}\n          {homeScale}\n        />\n        <div ref:controls>\n          <div class=\"nav\">\n            <div class=\"map\" style=\"display: {scale > 1.0 ? 'block' : 'block'};\">\n              <AppMiniMap \n                id=\"inceptionv1_{layerName}\"\n                {layerName}\n                bind:extent\n                enableDragging={true}\n                {classHeatmap}\n                {scaleCountFactor}\n              />\n            </div>\n            <div class=\"buttons\">\n              <Button on:click=\"refs.atlas.home(1000)\"><Navigation name=\"home\" color=\"white\"/></Button>\n              <Button on:click=\"refs.atlas.scaleBy(2)\"><Navigation name=\"add\" color=\"white\"/></Button>\n              <Button on:click=\"refs.atlas.scaleBy(0.5)\"><Navigation name=\"remove\" color=\"white\"/></Button>\n            </div>\n          </div>\n          <div>\n            <label><input type=checkbox bind:checked=\"$scroll\"> scroll to zoom</label>\n            <br>\n            <label><input type=checkbox bind:checked=showLabels> attribution labels</label>\n          </div>\n        </div>\n    </div>\n  </div>\n  <div class=\"options\" style=\"display: {showOptions ? 'block' : 'none'};\">\n    <Panel>\n      <h2 slot=\"head\">Options</h2>\n      <div slot=\"body\" class=\"options-body\">\n\n        <div>\n          <div>homeScale: {@html homeScale}</div>\n          <div>x: {@html format(gcx)}</div>\n          <div>y: {@html format(gcy)}</div>\n          <div>scale: {@html format(scale)}</div>\n          <label><input type=checkbox bind:checked=\"$scroll\"> scroll to zoom</label>\n        </div>\n        <div>\n        <h3>Attribution</h3>\n          <label><input type=checkbox bind:checked=showLabels> show labels</label>\n        </div>\n        <div class=\"grid-size\">\n          <h3>Grid size</h3>\n          <label><input type=radio bind:group=gridSize value={0}> 20x20</label>\n          <label><input type=radio bind:group=gridSize value={1}> 40x40</label>\n          <label><input type=radio bind:group=gridSize value={2}> 80x80</label>\n          <label><input type=radio bind:group=gridSize value={3}> 160x160</label>\n          <label><input type=radio bind:group=gridSize value={4}> 320x320</label>\n          <label><input type=radio bind:group=gridSize value={-1}> auto</label>\n          <div style=\"display: {gridSize == -1 ? 'block': 'none'};\">\n            <div>auto threshold: {@html autoGridSizeMultiplier}</div>\n            <input type=\"range\" min={0.6} max={1.4} step={0.01} bind:value=autoGridSizeMultiplier>\n          </div>\n        </div>\n        <div>\n          <h3>Icons</h3>\n          <div>density: {@html density}</div>\n          <input type=\"range\" min={0.2} max={8} step={0.01} bind:value=density>\n          <br>\n          <div>crop: {@html iconCrop}</div>\n          <input type=\"range\" min={0} max={0.5} step={0.01} bind:value=iconCrop>\n        </div>\n        <div style=\"display: {classHeatmap > -1 ? 'block' : 'none'}\">\n          <h3>Class filter</h3>\n          <div>Intensity: {@html classHeatmapMultiplier}</div>\n          <input type=\"range\" min=0.5 max=2 step=0.1 bind:value=classHeatmapMultiplier>\n          <label><input type=radio bind:group=classHeatmapPositive value={1}> positive influence</label>\n          <label><input type=radio bind:group=classHeatmapPositive value={-1}> negative influence</label>\n        </div>\n      </div>\n    </Panel>\n  </div>\n</div>\n\n\n<script>\nimport {format as f} from \"d3-format\";\n\nexport default {\n  components: { \n    Button: \"../library/Button.html\",\n    Navigation: \"../library/icons/Navigation.html\",\n    AppMiniMap: \"./AppMiniMap.html\",\n    AppLayerChooser: \"./AppLayerChooser.html\",\n    AppClassFilter: \"./AppClassFilter.html\",\n    Atlas: \"../Atlas.html\",\n    Panel: \"../library/App/Panel.html\"\n  },\n  data() {\n    return {\n      layerName: \"mixed4c\",\n      gridSize: 1,\n      classHeatmap: -1,\n      iconScaleFactor: 0.8,\n      iconCrop: 0.35,\n      showClassFilter: true,\n      showLayerChooser: true,\n      showOptions: true,\n      homeX: .5,\n      homeY: .5,\n      homeScale: 1\n    }\n  },\n  computed: {\n    realGridSize: ({gridSize}) => (gridSize + 1) * 20,\n    scaleCountFactor: ({iconScaleFactor, realGridSize}) =>  1000000 / (realGridSize * realGridSize * iconScaleFactor)\n  },\n  helpers: {\n    format: f(\".3f\")\n  }\n}\n</script>\n\n<style>\n  .container {\n    height: 100%;\n    box-sizing: border-box;\n    grid-column: screen;\n    display: flex;\n    overflow: hidden;\n    contain: strict;\n    font-size: 12px;\n    position: relative;\n  }\n\n  /*  */\n  .filter {\n    width: 170px;\n    border-right: solid 1px rgba(0, 0, 0, 0.2);\n  }\n  .stack {\n    overflow-y: scroll;\n    width: 170px;\n    border-right: solid 1px rgba(0, 0, 0, 0.2);\n    height: 100%;\n  }\n  .main {\n    flex-grow: 1;\n    padding: 8px;\n    box-sizing: border-box;\n    height: 100%;\n  }\n  .options {\n    width: 170px;\n    border-left: solid 1px rgba(0, 0, 0, 0.2);\n    line-height: 1.5em;\n  }\n  .options-body {\n    padding: 16px;\n  }\n  /*  */\n  ref:controls {\n    position: absolute;\n    right: 16px;\n    top: 16px;\n    padding: 8px;\n    background-color: white;\n    border-radius: 6px;\n    border: solid 1px rgba(0, 0, 0, 0.2);\n  }\n  ref:controls .nav {\n    display: flex;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n    margin-bottom: 8px;\n    padding-bottom: 12px;\n  }\n  ref:controls .map {\n    width: 104px;\n    margin-right: 8px;\n  }\n  ref:controls .buttons {\n    width: 32px;\n    display: grid;\n    grid-gap: 4px;\n\n  }\n  .options label {\n    display: block;\n  }\n  .atlas {\n    height: calc(100%);\n    position: relative;\n  }\n</style>",
    "<div class=\"hover\">\n  <table>\n  {#if top_class_indices}\n    {#each top_class_indices.slice(0,5) as top, i}\n      <tr>\n        <td style=\"width: 10px; text-align: right; padding-right: 4px;\">{i + 1}.</td>\n        <td class=\"{i == 0 ? 'first': ''}\">{$inceptionLabels[top]}</td>\n        <td style=\"text-align: right;\">{format(top_class_values[i])}</td>\n      </tr>\n    {/each}\n  {/if}\n  </table>\n  <div style=\"font-size: 10px; margin-top: 4px; color: #999; text-align: right;\">Average of {num_activations} activations</div>\n\n</div>\n\n<script>\n  import {format} from \"d3-format\";\n\n  export default {\n    helpers: {\n      format: format(\".2f\")\n    }\n  }\n</script>\n\n<style>\n.hover {\n  margin: 30px;\n  color: white;\n  font-size: 12px;\n  line-height: 14px;\n  background: rgba(0, 0, 0, 0.8);\n  padding: 8px;\n  border-radius: 8px;\n  border: solid 1px rgba(255, 255, 255, 0.4);\n  box-sizing: border-box;\n  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.4);\n  z-index: 10000;\n}\n.hover table {\n  width: 100%;\n  margin-bottom: 0;\n}\n.hover td {\n  font-size: 12px;\n  border-bottom: solid 1px rgba(255, 255, 255, 0.2);\n  padding: 6px 0;\n  margin: 6px 0;\n  color: rgba(255, 255, 255, 0.8);\n  overflow: ellipsis;\n}\n.hover td.first {\n  color: rgba(255, 255, 255, 1.0);\n  font-weight: bold;\n}\n\n.icon {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-radius: 4px;\n  border: solid 3px black;\n  pointer-events: none;\n  box-sizing: border-box;\n}\n</style>",
    "<!-- \n  //You first must add one component to the root document.\n  //It will automatically follow the mouse position.\n  //You should also save it to your global store, so all components have access.\n  //You must also pass in what component to use for rendering the data you will pass later.\n\n\t// A global tooltip\n\tstore.set({\n\t\ttooltip: new Tooltip({\n\t\t\ttarget: document.body,\n      store,\n\t\t\tdata: {\n\t\t\t\tcomponent: AtlasTooltip\n\t\t\t}\n\t\t})\n\t});\n\n  //When you want to show it:\n  const { tooltip } = this.store.get();\n  tooltip.show(\n    {\n      message: \"hello\"\n    }\n  );\n\n  //And when you want to hide it: \n  const { tooltip } = this.store.get();\n  tooltip.hide();\n\n -->\n\n<svelte:document on:mousemove=\"mousemove(event)\" />\n\n<div ref:root bind:clientHeight {style}>\n  {#if component}\n    <svelte:component this={component} ref:component/>\n  {/if}\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        visible: false,\n        width: 200,\n        component: null,\n      }\n    },\n    computed: {\n      style: ({x, width, y, clientHeight, visible}) => {\n        if (visible === false) {\n          return \"visibility: hidden;\";\n        } else {\n          const scrollLeft = document.documentElement.scrollLeft;\n          const scrollTop = document.documentElement.scrollTop;\n          const rightEdge = document.documentElement.clientWidth - width;\n          const bottomEdge = document.documentElement.clientHeight - clientHeight;\n          let left = Math.min(x, rightEdge);\n          let top = Math.min(y, bottomEdge);\n          if (x >= rightEdge && y >= bottomEdge) {\n            left = x - width;\n          }\n          return `width: ${width}px; top: ${top + scrollTop}px; left: ${left + scrollLeft}px;`;\n        }\n      },\n    },\n    methods: {\n      mousemove: function(event) {\n        const {visible} = this.get();\n        if (visible) {\n          this.set({\n            x: event.clientX,\n            y: event.clientY\n          });\n        }\n      },\n      show: function(d) {\n        this.set({visible: true});\n        this.refs.component.set({...d});\n      },\n      hide: function() {\n        this.set({\n          visible: false\n        });\n        \n      }\n    }\n  }\n</script>\n\n<style>\n  ref:root {\n    box-sizing: border-box;\n    pointer-events: none;\n    z-index: 1000000;\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n</style>",
    "<Radar bind:ready />\n\n{#if ready}\n  <AtlasDataLoader \n    {id} \n    {layer} \n    {layout}\n    {classFilter}\n    {filter}\n    bind:config\n    bind:layers \n    bind:labels \n  />\n{/if}\n\n<div ref:root\n  bind:clientWidth=viewWidth\n  bind:clientHeight=viewHeight\n>\n  <D3Zoom ref:d3Zoom\n    bind:scale\n    bind:translateX\n    bind:translateY\n    bind:mouseOver\n    bind:mouseGlobalPosition\n    bind:extent\n    bind:scrollWheel\n    {homeX}\n    {homeY}\n    {homeScale}\n  >\n    <canvas ref:canvas\n      width={viewWidth * screenResolution}\n      height={viewHeight * screenResolution}\n    ></canvas>\n    {#if showHoverIcon}\n    <div ref:hover\n      style=\"left: {hoverIconX}px; top: {hoverIconY}px; width: {hoverIconW}px; height: {hoverIconW}px;\"\n    ></div>\n    {/if}\n  </D3Zoom>\n</div>\n\n<script>\nimport { default as load } from './library/load.js';\nimport { max } from 'd3-array';\n\nexport default {\n  components: { \n    AtlasDataLoader: './AtlasDataLoader.html', \n    D3Zoom: './library/D3Zoom.html',\n    Radar: './library/Radar.html'\n  },\n  data() {\n    return {\n      ready: true,\n      id: \"inceptionv1_mixed4c\",\n      \n      config: null,\n      layers: null,\n      labels: null,\n\n      layer: 0,\n      layout: 0,\n      classFilter: 0,\n      filter: 0,\n\n      context: null,\n\n      alphaAttributionFactor: 0.02,\n      density: 1.0,\n      classHeatmap: -1,\n      classHeatmapMultiplier: 1,\n      classHeatmapPositive: 1,\n      iconCrop: 0.02,\n      autoGridSizeMultiplier: 0.8,\n\n      gridSize: null,\n\n      // for initial state, and going back to \"home\"\n      homeX: .5,\n      homeY: .5,\n      homeScale: 1,\n\n      // turn off features\n      enableClickToZoom: true,\n      enableHover: true,\n      enableDragToPan: true,\n\n      // Styling\n      backgroundColor: \"white\",\n      strokeColor: \"rgb(220, 220, 220)\",\n      strokeThickness: 1,\n      imageSmoothing: false,\n      fontSize: 10,\n      textColor: \"white\",\n      textShadowColor: \"rgba(0, 0, 0, 0.8)\",\n      showLabels: false,\n      textShadow: false,\n\n      screenResolution: 1,\n    }\n  },\n  computed: {\n    maxAttributionValue: ({layers, layer}) => {\n      if (layers == null) return 0;\n      const l = layers[layer];\n      let max = 0;\n      l.forEach(x => {\n        x.forEach(y => {\n          if (y && y.num_activations > 500) {\n            const v = y.full_class_values[0];\n            if (v > max) max = v;\n          }\n        })\n      })\n      return max;\n    },\n    w: ({viewWidth, screenResolution}) => viewWidth * screenResolution,\n    h: ({viewHeight, screenResolution}) => viewHeight * screenResolution,\n    currentZoomIndex: ({scale, gridSize, config, classHeatmap, viewWidth, viewHeight, autoGridSizeMultiplier}) => {\n      let s = 0;\n      if (gridSize > -1) {\n        s = +gridSize\n      } else {\n        const size = Math.min(viewWidth, viewHeight)\n        s = Math.floor(size * scale / 80 / 20 / autoGridSizeMultiplier);\n        console.log(\"s\", s)\n        // if (scale > 1 * 0.5) s = 0;\n        // if (scale > 2 * 0.5) s = 1;\n        // if (scale > 4 * 0.5) s = 2;\n        // if (scale > 8 * 0.5) s = 3;\n        // if (scale > 16 * 0.5) s = 4;\n      }\n      // Make sure we don't overrun our data\n      if (config) {\n        s = Math.min(config.grid_size.length - 1 , s);\n      }\n      // Class heatmap only has data up to level 2\n      if (classHeatmap > -1) {\n        s = Math.min(2, s);\n      }\n      return s;\n\n    },\n    visibleLayers: ({currentZoomIndex}) => {\n      return [currentZoomIndex];\n    },\n    currentLayerData: ({currentZoomIndex, layers}) => {\n      return layers ? layers[currentZoomIndex] : [[]]\n    },\n    showHover: ({hoverIconData, mouseGlobalPosition}) => mouseGlobalPosition && hoverIconData && hoverIconData.gcx,\n    hoverIconData: ({currentLayerData, config, mouseGlobalPosition, w, h, translateX, translateY}) => {\n      // const msx = mouseGlobalPosition[0]\n      // const msy = mouseGlobalPosition[1]\n      if (currentLayerData) {\n        const numGridRows = currentLayerData.length;\n        if (mouseGlobalPosition) {\n          const gx = Math.floor(mouseGlobalPosition[0] / Math.min(w, h) * numGridRows);\n          const gy = Math.floor(mouseGlobalPosition[1] / Math.min(w, h) * numGridRows);\n          if (currentLayerData[gy] && currentLayerData[gy][gx]) {\n            return currentLayerData[gy][gx];\n          } else {\n            return {};\n          }\n        } else {\n          return {};\n        }\n      } else {\n        return {};\n      }\n    },\n    hoverIconX: ({hoverIconData, scale, w, h, translateX}) => hoverIconData.gy * scale * Math.min(w, h) + translateX,\n    hoverIconY: ({hoverIconData, scale, w, h, translateY}) => hoverIconData.gx * scale * Math.min(w, h) + translateY,\n    hoverIconW: ({hoverIconData, scale, w, h}) => hoverIconData.gw * scale * Math.min(w, h),\n    showHoverIcon: ({mouseGlobalPosition, hoverIconData, enableHover}) => {\n      return enableHover && mouseGlobalPosition && hoverIconData && hoverIconData.gw\n    },\n  },\n  onupdate({changed, current, previous}) {\n    // console.log(\"atlas\", changed, current.scale)\n    if (!current.context || changed.viewWidth || changed.viewHeight) {\n      this.set({context: this.refs.canvas.getContext('2d')});\n    }\n    if (changed.autoGridSizeMultiplier || changed.density || changed.maxAttributionValue || changed.classHeatmap || changed.classHeatmapMultiplier || changed.classHeatmapPositive || changed.showLabels || changed.viewWidth || changed.viewHeight || changed.scale || changed.translateX || changed.translateY || changed.iconCrop || changed.gridSize || changed.layers) {\n      this.render();\n    }\n    if (changed.hoverIconData) {\n      const {tooltip} = this.store.get();\n      const {showHoverIcon} = this.get();\n      if (showHoverIcon) {\n        tooltip.show(current.hoverIconData);\n      } else {\n        tooltip.hide();\n      }\n    }\n    if (changed.showHoverIcon) {\n      if (current.showHoverIcon == false) {\n        const { tooltip } = this.store.get();\n        tooltip.hide();\n      }\n    }\n\n  },\n  oncreate() {\n    // this.home(0);\n  },\n  methods: {\n    fullscreen() {\n      this.refs.root.webkitRequestFullscreen();\n    },\n    home(duration=0) {\n      // const {homeX, homeY, homeScale} = this.get();\n      // this.transitionTo(homeX, homeY, homeScale, duration);\n      this.refs.d3Zoom.home(duration);\n    },\n    transitionTo(x, y, scale, duration=0) {\n      this.refs.d3Zoom.transformTo(x, y, scale, duration);\n    },\n    scaleBy(multiplier) {\n      const { scale } = this.get();\n      this.refs.d3Zoom.scaleTo(scale * multiplier, 300);\n    },\n    iconToGlobalPosition(icon, layerIndex) {\n      const {density, scale, translateX, translateY, config, w, h} = this.get();\n      const gridSize = config.grid_size[layerIndex];\n      const gridWidth = config.icon_size * gridSize;\n\n      const iconWidth = icon.gw * scale * Math.min(w, h);\n\n      // x, y swapped intentionally\n      const iconX = icon.gy * scale * Math.min(w, h) + translateX;\n      const iconY = icon.gx * scale * Math.min(w, h) + translateY;\n\n      const sourceX = icon.localX * config.icon_size;\n      const sourceY = icon.localY * config.icon_size;\n\n      const totalSamples = (typeof config.filter[0] == \"number\" ? config.filter[0] : config.sample_images)\n      const avgSamples = totalSamples / (gridSize * gridSize);\n\n      // Resize based on density\n      const relativeDensity = Math.min(1, Math.sqrt(density * icon.num_activations / avgSamples));\n      const adjustedIconWidth = iconWidth * relativeDensity;\n      const adjustedIconX = iconX + (iconWidth - adjustedIconWidth) / 2;\n      const adjustedIconY = iconY + (iconWidth - adjustedIconWidth) / 2\n\n      return {sourceX, sourceY, iconX: adjustedIconX, iconY: adjustedIconY, iconWidth: adjustedIconWidth}\n    },\n    clear() {\n      const {viewHeight, viewWidth, context, backgroundColor} = this.get();\n      context.globalAlpha = 1;\n      context.fillStyle= backgroundColor;\n      context.clearRect(0, 0, viewWidth, viewHeight);\n      context.fillRect(0, 0, viewWidth, viewHeight);\n    },\n    render() {\n\n      const {id, imageSmoothing, scale, w, h, translateX, translateY, context, backgroundColor, config, layers, visibleLayers, currentZoomIndex, strokeColor, strokeThickness, fontSize,textShadowColor, textColor, maxAttributionValue, classHeatmapMultiplier} = this.get();\n\n      this.clear();\n      // context.imageSmoothingQuality = \"low\";\n      context.imageSmoothingEnabled = imageSmoothing;\n\n      if (config && layers) {\n\n        layers.forEach((icons, layerIndex) => {\n          if (visibleLayers.indexOf(layerIndex) > -1) {\n            \n            // Calculating min and max indices for icon render loop\n            const minSize = Math.min(w, h);\n            const minX = Math.max(0, Math.floor(-(translateX / scale / minSize) * icons.length));\n            const maxX = minX + Math.ceil(( w / scale / minSize) * icons.length);\n            const minY = Math.max(0, Math.floor(-(translateY / scale / minSize) * icons.length));\n            const maxY = minY + Math.ceil(( h / scale / minSize) * icons.length);\n\n            for (let y = minY; y <= maxY; y++) {\n              for (let x = minX; x <= maxX; x++) {\n                \n                if (icons[y] && icons[y][x]) {\n                  const icon = icons[y][x];\n\n                  const {classHeatmap, sourceX, sourceY, iconX, iconY, iconWidth} = this.iconToGlobalPosition(icon, layerIndex);\n                  \n                  const requestedID = id;\n                  // If icon is in the viewport \n                  // probably don't need this anymore\n                  // if (iconX > -iconWidth && iconX < w && iconY > -iconWidth && iconY < h) {\n                  if (true) {\n                    \n                    // We want to draw a box so there isn't just whiteness.\n                    if (classHeatmap > -1) {\n                      context.globalAlpha = 0.75;\n                      context.strokeStyle = strokeColor;\n                      context.lineWidth = strokeThickness;\n                      context.fillStyle = \"white\";\n                      context.beginPath();\n                      context.rect(iconX, iconY, iconWidth, iconWidth);\n                      context.stroke();\n                      context.fill();\n                      context.closePath();\n                    }\n\n                    load(icon.url).then(response => {\n                      // check that we're still on the right layer/zoom/id\n                      const {id, visibleLayers, iconCrop, showLabels, textShadow} = this.get();\n                      // console.log(requestedID, id)\n                      if(visibleLayers.indexOf(layerIndex) > -1 && requestedID === id) {\n                        const {alphaAttributionFactor, labels, config, classHeatmap, classHeatmapMultiplier, classHeatmapPositive} = this.get();\n\n                        const {sourceX, sourceY, iconX, iconY, iconWidth} = this.iconToGlobalPosition(icon, layerIndex);\n\n                        // If we have a class heatmap active, calculate the transparency for the current icon\n                        let a = 1;\n                        if (classHeatmap > -1) {\n                          let i = icon.full_class_indices.indexOf(classHeatmap);\n                          if (i > -1) {\n                            a = icon.full_class_values[i] / maxAttributionValue;\n                            a = a * classHeatmapPositive;\n                            a = Math.max(0, a) * classHeatmapMultiplier;\n                          } else {\n                            a = 0.0;\n                          }\n                        }\n\n                        // draw the icon\n                        context.globalAlpha = a;\n                        const iconOffset = (iconCrop * config.icon_size) / 2;\n                        context.clearRect(iconX + 1, iconY + 1, iconWidth - 2, iconWidth - 2);\n                        context.drawImage(response,\n                          //source\n                          sourceY + iconOffset, sourceX + iconOffset, config.icon_size - iconOffset * 2, config.icon_size - iconOffset * 2,\n                          //destination\n                          iconX, iconY, iconWidth, iconWidth\n                        );\n                        context.globalAlpha = 1;\n\n                        if (showLabels && labels) {\n                          context.globalAlpha = 1;\n                          context.font=fontSize + \"px Helvetica\";\n                          if (textShadow) {\n                            context.lineWidth = 2;\n                            context.strokeStyle = textShadowColor;\n                            context.strokeText(labels[icon.top_class_indices[0]], iconX + 4, iconY + iconWidth - 4, iconWidth - 8);\n                          }\n                          context.fillStyle = textColor;\n                          context.fillText(labels[icon.top_class_indices[0]], iconX + 4, iconY + iconWidth - 4, iconWidth - 8);\n                        }\n\n                      }\n\n                    })\n                  }\n                }\n              }\n            }\n          }\n        })\n      }\n    }\n    }\n  }\n\n</script>\n\n\n<style>\n  ref:root {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    contain: layout;\n    overflow: hidden;\n  }\n  ref:stage {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n  ref:canvas {\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 8px;\n  }\n  ref:hover {\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 4px;\n    border: solid 3px black;\n    pointer-events: none;\n    box-sizing: border-box;\n  }\n</style>",
    "<button\n  on:click=\"fire('click')\"\n>\n  <slot></slot>\n</button>\n\n<script>\nexport default {\n\n}\n\n</script>\n\n<style>\n  button {\n    /* border: solid 2px rgb(255, 130, 0); */\n    outline: none;\n    font-size: 13px;\n    border: none;\n    color: white;\n    padding: 0 4px;\n    background-color: rgb(255, 130, 0);\n    font-weight: 500;\n    height: 32px;\n    line-height: 1em;\n    border-radius: 4px;\n    text-transform: uppercase;\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    vertical-align: middle;\n    -webkit-font-smoothing: antialiased;\n  }\n</style>",
    "<div ref:root>\n  <Placeholder>\n    <!-- <AtlasThumbnail\n      ref:overview\n      {id}\n      {classHeatmap}\n      gridSize={1} \n      iconCrop={0.6} \n      {scaleCountFactor}\n      backgroundColor=\"#f0f0f0\"\n    /> -->\n    <!-- <AtlasThumbnail \n      {layerName}\n    /> -->\n    <img src=\"assets/images/renders/thumbnail-{layerName}.jpg\" alt=\"thumbnail for {layerName}\">\n    <AtlasReticle\n      bind:extent\n      enableDragging={true}\n    />\n  </Placeholder>\n</div>\n\n<script>\n  export default {\n    components: {\n      // AtlasThumbnail: \"../AtlasThumbnail.html\",\n      AtlasReticle: \"../AtlasReticle.html\",\n      Placeholder: \"../library/Placeholder.html\"\n    },\n    data() {\n      return {\n        scaleCountFactor: 200\n      }\n    }\n  }\n</script>\n\n<style>\nref:root {\n  position: relative;\n  width: 100%; \n  height: 100%;\n  box-sizing: border-box;\n  padding: 1px;\n}\nimg {\n  display: block;\n  width: 100%;\n  opacity: 0.4;\n}\n</style>",
    "<div class=\"stack\">\n{#each layers as layer, i}\n  <label class=\"layer {layerName == layer ? 'selected' : ''}\">\n    <input type=radio bind:group=layerName value={layer}>\n    <div style=\"width: 50px; position: relative;\">\n      <AtlasThumbnail layerName={layer} {classHeatmap}/>\n    </div>\n    <span>{layer}</span>\n  </label>\n{/each}\n</div>\n\n<script>\n  export default {\n    components: {\n      AtlasThumbnail: \"../AtlasThumbnail.html\"\n    },\n    data() { return {\n      layerName: \"mixed4c\",\n      layers: [\n        \"mixed3b\",\n        \"mixed4a\",\n        \"mixed4b\",\n        \"mixed4c\",\n        \"mixed4d\",\n        \"mixed4e\",\n        \"mixed5a\",\n        \"mixed5b\",\n      ],\n      classHeatmap: -1\n    }; }\n  }\n</script>\n\n<style>\n.layer {\n  position: relative;\n  cursor: pointer;\n  display: grid;\n  align-items: center;\n  grid-template-columns: 1fr 1.5fr;\n  font-size: 11px;\n  text-transform: uppercase;\n  padding: 5px 16px 5px 16px;\n  color: grey;\n  border-left: solid 3px rgba(255, 255, 255, 0);\n  border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n}\n.layer input {\n  position: absolute;\n  opacity: 0;\n}\n.layer span {\n  margin-left: 8px;\n}\n.layer.selected {\n  border-left-color: rgb(255, 130, 0);\n  color: rgb(255, 130, 0);\n  background-color: rgba(255, 130, 0, 0.08);\n  font-weight: bold;\n}\n.layer :global(canvas) {\n  opacity: 0.5;\n}\n.layer.selected :global(canvas) {\n  /* opacity: 1; */\n}\n</style>",
    "<div class=\"chooser\">\n  {#each labels as l}\n    <label class=\"{classHeatmap === l.i ? 'selected' : ''}\">\n      <input type=radio bind:group=classHeatmap value={l.i}>\n      <span title=\"{l.i}\">{l.label}</span>\n    </label>\n  {/each}\n</div>\n\n<script>\nimport classesToKeep from './../classesToKeep.js';\nimport inceptionLabels from './../Labels.js';\n\nexport default {\n  data() {\n    return {\n      classesToKeep,\n      inceptionLabels,\n      classHeatmap: 235\n    }\n  },\n  computed: {\n    labels: ({inceptionLabels}) => {\n      let out = classesToKeep.map(k => {\n        let l = inceptionLabels.inception[k];\n        return {label: l, i: k};\n      });\n      return [{label: \"show all\", i: -1}].concat(out);\n    }\n  }\n}\n</script>\n\n<style>\n  .chooser {\n    height: auto;\n  }\n  .chooser label {\n    position: relative;\n    font-size: 11px;\n    line-height: 1.2em;\n    display: block;\n    border-left: solid 3px white;\n    padding: 5px 16px 5px 16px;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-y: hidden;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.1);\n  }\n  .chooser label input {\n    position: absolute;\n    opacity: 0;\n  }\n  .chooser label.selected {\n    border-left-color: rgb(255, 130, 0);\n    color: rgb(255, 130, 0);\n    background-color: rgba(255, 130, 0, 0.08);\n    font-weight: bold;\n  }\n</style>",
    "<div class=\"root\">\n  <div class=\"head\">\n    <slot name=\"head\"></slot>\n  </div>\n  <div class=\"body\">\n    <slot name=\"body\"></slot>\n  </div>\n</div>\n\n<style>\n  .root {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n  }\n  :global() .head {\n    height: 60px;\n    padding: 0 16px;\n    border-bottom: solid 1px rgba(0, 0, 0, 0.2);\n    /* box-sizing: border-box; */\n    display: flex;\n    align-items: center;\n    flex: 0 0 60px;\n  }\n  :global() .head h2 {\n    font-size: 16px;\n    font-weight: bold;\n    line-height: 1.4em;\n    margin: 0;\n    padding: 0;\n    border: none;\n  }\n  :global() .body {\n    position: relative;\n    flex: 1;\n    overflow-y: scroll;\n    font-size: 11px;\n    line-height: 1.6em;\n  }\n  :global() .body h3 {\n    font-size: 12px;\n    font-weight: 600;\n    line-height: 1.2em;\n    text-transform: uppercase;\n    margin: 8px 0;\n    height: auto;\n    border-top: solid 1px rgba(0, 0, 0, 0.1);\n    padding-top: 1em;\n  }\n</style>",
    "<div \n  ref:root \n  class=\"d3zoom\" \n  bind:clientWidth\n  bind:clientHeight\n  on:mousemove=\"mouseMove(event)\"\n  on:mousedown=\"set({msx: null, msy: null})\"\n  on:mouseout=\"set({msx: null, msy: null})\"\n>\n  <slot />\n</div>\n\n<script>\nimport {zoomIdentity as d3ZoomIdentity, zoom as d3Zoom, zoomTransform as d3ZoomTransform} from \"d3-zoom\";\nimport {event as d3Event, select as d3Select} from \"d3-selection\";\nimport { tween } from 'svelte-extras';\nimport * as eases from 'eases-jsnext';\n\nexport default {\n  data() {\n    return {\n      z: d3Zoom(), //d3 zoom object\n      el: null,\n      selection: null, //the d3 selection of the root\n      transform: null, // the d3 transform\n      scaleExtent: [1, 32], //\n      scrollWheel: false,\n      homeScale: 1,\n      homeX: 0.5,\n      homeY: 0.5,\n      scale: null,\n      translateX: null,\n      translateY: null,\n      k: 1,\n      x: 0,\n      y: 0,\n      msx: null,\n      msy: null,\n    };\n  },\n  computed: {\n    minSize: ({clientWidth, clientHeight}) => Math.min(clientWidth, clientHeight),\n    mouseOver: ({msx, msy}) => msx != undefined && msy != undefined,\n    mouseGlobalPosition: ({transform, msx, msy, clientHeight, clientWidth, minSize}) => {\n      if (transform && msx != undefined && msy != undefined) {\n        return [\n          transform.invertX(msx),// - (clientWidth - minSize) / 2,\n          transform.invertY(msy),// - (clientHeight - minSize) / 2,\n        ];\n      } else {\n        return null;\n      }\n    },\n    extent: ({scale, translateX, translateY, minSize, clientWidth, clientHeight}) => {\n      const x0 = - translateX / scale;\n      const y0 = - translateY / scale;\n      const x1 = x0 + clientWidth / scale;\n      const y1 = y0 + clientHeight / scale;\n      return [\n        [x0 / minSize, x1 / minSize],\n        [y0 / minSize, y1 / minSize],\n      ]\n    },\n    gcx: ({extent}) => (extent[0][0] + extent[1][0]) / 2,\n    gcy: ({extent}) => (extent[0][1] + extent[1][1]) / 2,\n  },\n  \n  oncreate() {\n    const {z, scaleExtent, minSize, clientWidth, clientHeight, homeScale, homeX, homeY} = this.get();\n    const that = this; // needed because d3 gives \"this\" as the node, not component.\n    z.wheelDelta(() => {\n      let d = -d3Event.deltaY * (d3Event.deltaMode ? 120 : 1) / 500;\n      if (d3Event.ctrlKey) {\n        d = d * 10;\n      }\n      return d;\n    });\n    z.scaleExtent(scaleExtent);\n    const selection = d3Select(this.refs.root);\n    this.set({\n      selection,\n      el: this.refs.root,\n    });\n    z(selection);\n    z.filter(this.zoomEventFilter.bind(this));\n    z.on(\"zoom\", () => { this.onzoom(that); });\n    z.translateTo(selection, homeX * minSize, homeY * minSize)\n    z.scaleTo(selection, homeScale);\n  },\n  onstate({changed, current, previous}) {\n    if (previous != undefined) {\n      if ((changed.clientWidth || changed.clientHeight) && current.el) {\n        this.update();\n      }\n    }\n    // console.log(\"update\", changed, current.scale)\n    const {z, selection, el, x, y} = this.get();\n    // if (changed.scaleExtent && current.scaleExtent) { z.scaleExtent(current.scaleExtent) } \n    if (selection) {\n\n      // if (changed.x || changed.y) {\n      //   z.translateTo(selection, current.x, current.y);\n      // }\n\n      // if (changed.scale) { this.set({k: current.scale}); }\n      // if (changed.k) { z.scaleTo(selection, current.k); } \n\n      // if (changed.translateX) { this.set({x: current.translateX}); }\n      // if (changed.translateY) { this.set({x: current.translateY}); }\n\n    }\n  },\n  methods: {\n    tween,\n    zoomEventFilter: function() {\n      const {scrollWheel} = this.get();\n      // console.log(d3Event);\n      // If we want to suppress scroll wheel events...\n      if (!scrollWheel) {\n        // ... return false for scroll wheel events + button = 1 events\n        return !(d3Event.type === \"wheel\" && d3Event.ctrlKey === false) && d3Event.button == 0;\n      } else {\n        //... just return false for button = 1 events\n        return d3Event.button == 0;\n      }\n    },\n    mouseMove: function(event) {\n      const msx = event.offsetX;\n      const msy = event.offsetY;\n      this.set({\n        msx, msy\n      });\n      const {mouseGlobalPosition} = this.get();\n    },\n    update: function() {\n      \n      const {clientWidth, clientHeight, minSize, el, z} = this.get();\n      const transform = d3ZoomTransform(el);\n      // console.log(\"update\", transform.k)\n      const scale = transform.k;\n      this.set({\n        scale,\n        transform,\n        translateX: transform.x, // + scale * (clientWidth - minSize) / 2,\n        translateY: transform.y, // + scale * (clientHeight - minSize) / 2,\n      });\n    },\n    onzoom: function(that) {\n      // console.log(\"onzoom\")\n      that.update();\n    },\n    zoomTo: function(x, y, scale = 1, duration = 1000) {\n      const {selection, z, minSize, clientWidth, clientHeight} = this.get();\n\n      selection.transition()\n        .duration(duration)\n        .call(z.transform, \n          d3ZoomIdentity\n            .translate(clientWidth / 2, clientHeight / 2)\n            .scale(scale)\n            .translate(- x * minSize, - y * minSize));\n    },\n    translateTo: function(x, y) {\n      const {z, selection, minSize} = this.get();\n      z.transform(selection, x * minSize, y * minSize)\n    },\n    home: function(duration = 0) {\n\n      const {homeX, homeY, homeScale} = this.get();\n      this.zoomTo(homeX, homeY, homeScale)\n\n      // selection.transition()\n      //   .duration(duration)\n      //   .call(z.transform, \n      //     d3ZoomIdentity\n      //       .translate(clientWidth / 2, clientHeight / 2)\n      //       .translate(- 0.5 * minSize, - 0.5 * minSize));\n    },\n    scaleTo: function(scale, duration=0) {\n      // console.log(\"scaleTo\", duration)\n      const {z, selection} = this.get();\n      selection.transition()\n        .duration(duration)\n        .call(z.scaleTo, scale);\n    }\n  }\n}\n</script>\n\n<style>\nref:root {\n  position: relative;\n  background: white;\n  width: 100%;\n  height: 100%;\n}\n</style>",
    "<div class=\"root\" bind:clientWidth bind:clientHeight>\n  {#if extent}\n  <svg width={clientWidth} height={clientHeight}>\n    <path\n      class=\"{background ? '' : 'transparent'}\"\n      on:mousemove=\"mouseMove(event)\"\n      on:mouseup=\"mouseUp(event)\"\n      d=\"M0,0 L{clientWidth},0 L{clientWidth},{clientHeight} L0,{clientHeight} z M{left},{top} L{left},{bottom} L{right},{bottom}  L{right},{top} z\"\n    />\n  </svg>\n    <div\n      class=\"reticle {round ? 'round' : ''}\"\n      on:mousemove=\"mouseMove(event)\"\n      on:mousedown=\"mouseDown(event)\"\n      on:mouseup=\"mouseUp(event)\"\n      style=\"\n        border-color: {color};\n        top:{top}px;\n        left:{left}px; \n        width:{right-left}px; \n        height:{bottom-top}px; \n        \"\n    >\n\n    {#if annotationValue}\n      <div class=\"annotationTabParent\" style=\"top:{(w * width-2)/2}px;\">\n        <div class=\"annotationTab\" style=\"background:{color};\">\n          <p class=\"annotation\"\n            >{annotationValue} \n          </p>\n        </div>\n      </div>\n    {/if}\n  </div>\n  {/if}\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        dragging: false,\n        extent: [[],[]],\n        background: true,\n        round: false,\n        color: \"rgb(255, 130, 0)\",\n        // color: \"rgba(100, 100, 100, 0.5)\",\n        enableDragging: true,\n      }\n    },\n    computed: {\n      left: ({clientWidth, extent}) => Math.min(clientWidth, Math.max(0, extent[0][0] * clientWidth)),\n      right: ({clientWidth, extent}) => Math.min(clientWidth, extent[0][1] * clientWidth),\n      top: ({clientHeight, extent}) => Math.min(clientHeight, Math.max(0, extent[1][0] * clientHeight)),\n      bottom: ({clientHeight, extent}) => Math.min(clientHeight, extent[1][1] * clientHeight),\n    },\n    methods: {\n      mouseUp() {\n        const { startPos, height, width, scale, aspectRatio, gcx, gcy} = this.get();\n        this.set({dragging: false})\n      },\n      mouseDown(event) {\n        const {enableDragging} = this.get();\n        if(enableDragging){\n          event.preventDefault();\n          this.set({dragging: true, startPos: {x: event.screenX, y: event.screenY}})\n        }\n      },\n      mouseMove(event) {\n        const {dragging, startPos, scale, width, aspectRatio, height, left, top} = this.get();\n        if(dragging){\n           this.set({\n              gcx: (event.screenX - startPos.x + left) / width + 1 / scale * aspectRatio / 2, \n              gcy: (event.screenY - startPos.y + top) / height + 1 / scale / 2, \n           })\n           this.set({\n            startPos: {x: event.screenX, y: event.screenY}\n           })\n        }\n      },\n    },\n  }\n</script>\n\n<style>\n  svg {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n  svg path {\n    fill: white;\n    fill-opacity: 0.7;\n  }\n  svg path.transparent {\n    fill-opacity: 0;\n  }\n  .root {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n  }\n  .reticle {\n    top: 0;\n    left: 0;\n    position: absolute;\n    border: solid 1px black;\n    border-width: 2px;\n    box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);\n    box-sizing: border-box;\n    background: rgba(0, 0, 0, 0);\n    border-radius: 4px;\n  }\n  .reticle.round {\n    border-radius: 50%;\n  }\n  .annotationTabParent {\n    position: absolute;\n    left:0px;\n  }\n  .annotationTab {\n    width: 16px;\n    height: 16px;\n    left: -16px;\n    top: -8px;\n    position: absolute;\n    border-radius: 3px 0px 0px 3px;\n  }\n  .annotation {\n    font-size: 12px;\n    top: -6px;\n    left: 4px;\n    color: white;\n    position: absolute;\n    text-align: center;\n  }\n</style>",
    "<div class=\"root\" bind:clientWidth style=\"display: {display}; padding-bottom: {100 / aspectRatio}%\">\n  <div class=\"container\">\n    <slot></slot>\n  </div>\n</div>\n\n<script>\n  export default {\n    data() {\n      return {\n        display: \"block\",\n        aspectRatio: 1,\n        clientWidth: 0,\n        \n      }\n    },\n    computed: {\n      width: ({clientWidth}) => clientWidth,\n      height: ({width, aspectRatio}) => width / aspectRatio\n    }\n  }\n</script>\n\n<style>\n.root {\n  position: relative;\n  box-sizing: border-box;\n}\n.container {\n  position: absolute;\n  box-sizing: border-box;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n</style>",
    "\n<div bind:clientWidth style=\"height: {height}px;\">\n  <canvas ref:canvas width={gridSize} height={gridSize} style=\"width: {clientWidth}px; height: {height}px;\"></canvas>\n</div>\n\n<script>\nimport { load } from 'lucid-components';\nimport classesToKeep from './classesToKeep.js';\n\nexport default {\n  data() {\n    return {\n      root: \"https://storage.googleapis.com/activation-atlas/build\",\n      model: \"inceptionv1\",\n      layerName: \"mixed4d\",\n      grid: 1,\n      layout: 0,\n      gridSize: 10,\n      classHeatmap: -1,\n      icons: []\n    };\n  },\n  computed: {\n    height: ({clientWidth}) => clientWidth,\n    id: ({model, layerName}) => model + \"_\" + layerName\n  },\n  oncreate() {\n    const {root, id, grid} = this.get();\n    load(`${root}/${id}/${id}.json`).then(config => {\n      // console.log(\"config: \", config)\n      if (config.class_filter == null) { config.class_filter = \"None\" }\n      if (config.filter == null) { config.filter = \"None\" }\n      if (!Array.isArray(config.layout)) {config.layout = [config.layout]}\n      if (!Array.isArray(config.layer)) {config.layer = [config.layer]}\n      if (!Array.isArray(config.filter)) {config.filter = [config.filter]}\n      this.set({gridSize: config.grid_size[grid]})\n      const url = `${root}/${id}/web/web--grid_size=${config.grid_size[grid]}--layout=${config.layout[0]}--class_filter=${config.class_filter}--filter=${config.filter[0]}--layer=${config.layer[0]}--model=${config.model}--sample_images=${config.sample_images}--sample_type=${config.sample_type}.json`\n      // console.log(\"config\", config)\n      load(url).then(web => {\n        // console.log(\"web\", web)\n        this.set({icons: web});\n        this.render();\n      })\n    })\n  },\n  onupdate({changed}) {\n    if (changed.classHeatmap) {\n      this.render();\n    }\n  },\n  methods: {\n    render() {\n      const {grid, gridSize, icons, classHeatmap} = this.get();\n      const context = this.refs.canvas.getContext('2d');\n      let imageData = context.getImageData(0, 0, gridSize, gridSize);\n      let data = imageData.data;\n      // for (var i = 0; i < data.length; i += 4) {\n        // data[i] = 100;\n        // data[i + 1] = 100;\n        // data[i + 2] = 100;\n        // data[i + 3] = 255;\n      // }\n      for (const icon of icons) {\n        let heatmapMultiplier = 1.0;\n        if (classHeatmap > -1) {\n          let ci = classesToKeep.indexOf(classHeatmap);\n          let value = Math.max(0, icon.f[ci]);\n          heatmapMultiplier = Math.max(0.1, value * 20);\n          // console.log(ci, value)\n        }\n        const y = icon.x; //x,y switched on purpose \n        const x = icon.y; //x,y switched on purpose\n        // data[y * gridSize * 4 + x * 4 + 0] = (heatmapMultiplier) * 255 * 20;\n        // data[y * gridSize * 4 + x * 4 + 1] = (heatmapMultiplier) * 130 * 20;\n        // data[y * gridSize * 4 + x * 4 + 2] = (heatmapMultiplier) * 1 * 20;\n        data[y * gridSize * 4 + x * 4 + 3] = 0.005 * 255 * (icon.n / Math.pow((grid + 1), 2)) * heatmapMultiplier;\n      }\n      \n      context.putImageData(imageData, 0, 0);\n    }\n  }\n}\n\n\n</script>\n<style>\ncanvas {\n  image-rendering: pixelated;\n}\n</style>"
  ],
  "names": [],
  "mappings": "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"
}